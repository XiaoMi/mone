{"version":3,"file":"parse-html.js","sourceRoot":"","sources":["../../../src/htmlParser/parse-html.ts"],"names":[],"mappings":"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","sourcesContent":["import { State } from './state';\nimport { letterRe, digitRe, whitespaceRe, quoteRe, controlCharsRe } from '../regex-lib';\nimport { assertNever } from '../utils';\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n/**\n * Parses an HTML string, calling the callbacks to notify of tags and text.\n *\n * ## History\n *\n * This file previously used a regular expression to find html tags in the input\n * text. Unfortunately, we ran into a bunch of catastrophic backtracking issues\n * with certain input text, causing Autolinker to either hang or just take a\n * really long time to parse the string.\n *\n * The current code is intended to be a O(n) algorithm that walks through\n * the string in one pass, and tries to be as cheap as possible. We don't need\n * to implement the full HTML spec, but rather simply determine where the string\n * looks like an HTML tag, and where it looks like text (so that we can autolink\n * that).\n *\n * This state machine parser is intended just to be a simple but performant\n * parser of HTML for the subset of requirements we have. We simply need to:\n *\n * 1. Determine where HTML tags are\n * 2. Determine the tag name (Autolinker specifically only cares about <a>,\n *    <script>, and <style> tags, so as not to link any text within them)\n *\n * We don't need to:\n *\n * 1. Create a parse tree\n * 2. Auto-close tags with invalid markup\n * 3. etc.\n *\n * The other intention behind this is that we didn't want to add external\n * dependencies on the Autolinker utility which would increase its size. For\n * instance, adding htmlparser2 adds 125kb to the minified output file,\n * increasing its final size from 47kb to 172kb (at the time of writing). It\n * also doesn't work exactly correctly, treating the string \"<3 blah blah blah\"\n * as an HTML tag.\n *\n * Reference for HTML spec:\n *\n *     https://www.w3.org/TR/html51/syntax.html#sec-tokenization\n *\n * @param {String} html The HTML to parse\n * @param {Object} callbacks\n * @param {Function} callbacks.onOpenTag Callback function to call when an open\n *   tag is parsed. Called with the tagName as its argument.\n * @param {Function} callbacks.onCloseTag Callback function to call when a close\n *   tag is parsed. Called with the tagName as its argument. If a self-closing\n *   tag is found, `onCloseTag` is called immediately after `onOpenTag`.\n * @param {Function} callbacks.onText Callback function to call when text (i.e\n *   not an HTML tag) is parsed. Called with the text (string) as its first\n *   argument, and offset (number) into the string as its second.\n */\nexport function parseHtml(\n    html: string,\n    {\n        onOpenTag,\n        onCloseTag,\n        onText,\n        onComment,\n        onDoctype,\n    }: {\n        onOpenTag: (tagName: string, offset: number) => void;\n        onCloseTag: (tagName: string, offset: number) => void;\n        onText: (text: string, offset: number) => void;\n        onComment: (offset: number) => void;\n        onDoctype: (offset: number) => void;\n    }\n) {\n    const noCurrentTag = new CurrentTag();\n\n    let charIdx = 0,\n        len = html.length,\n        state = State.Data as State,\n        currentDataIdx = 0, // where the current data start index is\n        currentTag = noCurrentTag; // describes the current tag that is being read\n\n    // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'currentDataIdx', 'currentOpenTagIdx', 'tag.type' ]\n    // } );\n\n    while (charIdx < len) {\n        var char = html.charAt(charIdx);\n\n        // For debugging: search for other \"For debugging\" lines\n        // ALSO: Temporarily remove the 'const' keyword on the State enum\n        // table.push(\n        // \t[ charIdx, char, State[ state ], currentDataIdx, currentTag.idx, currentTag.idx === -1 ? '' : currentTag.type ]\n        // );\n\n        switch (state) {\n            case State.Data:\n                stateData(char);\n                break;\n            case State.TagOpen:\n                stateTagOpen(char);\n                break;\n            case State.EndTagOpen:\n                stateEndTagOpen(char);\n                break;\n            case State.TagName:\n                stateTagName(char);\n                break;\n            case State.BeforeAttributeName:\n                stateBeforeAttributeName(char);\n                break;\n            case State.AttributeName:\n                stateAttributeName(char);\n                break;\n            case State.AfterAttributeName:\n                stateAfterAttributeName(char);\n                break;\n            case State.BeforeAttributeValue:\n                stateBeforeAttributeValue(char);\n                break;\n            case State.AttributeValueDoubleQuoted:\n                stateAttributeValueDoubleQuoted(char);\n                break;\n            case State.AttributeValueSingleQuoted:\n                stateAttributeValueSingleQuoted(char);\n                break;\n            case State.AttributeValueUnquoted:\n                stateAttributeValueUnquoted(char);\n                break;\n            case State.AfterAttributeValueQuoted:\n                stateAfterAttributeValueQuoted(char);\n                break;\n            case State.SelfClosingStartTag:\n                stateSelfClosingStartTag(char);\n                break;\n            case State.MarkupDeclarationOpenState:\n                stateMarkupDeclarationOpen(char);\n                break;\n            case State.CommentStart:\n                stateCommentStart(char);\n                break;\n            case State.CommentStartDash:\n                stateCommentStartDash(char);\n                break;\n            case State.Comment:\n                stateComment(char);\n                break;\n            case State.CommentEndDash:\n                stateCommentEndDash(char);\n                break;\n            case State.CommentEnd:\n                stateCommentEnd(char);\n                break;\n            case State.CommentEndBang:\n                stateCommentEndBang(char);\n                break;\n            case State.Doctype:\n                stateDoctype(char);\n                break;\n\n            default:\n                assertNever(state);\n        }\n\n        // For debugging: search for other \"For debugging\" lines\n        // ALSO: Temporarily remove the 'const' keyword on the State enum\n        // table.push(\n        // \t[ charIdx, char, State[ state ], currentDataIdx, currentTag.idx, currentTag.idx === -1 ? '' : currentTag.type ]\n        // );\n\n        charIdx++;\n    }\n\n    if (currentDataIdx < charIdx) {\n        emitText();\n    }\n\n    // For debugging: search for other \"For debugging\" lines\n    // console.log( '\\n' + table.toString() );\n\n    // Called when non-tags are being read (i.e. the text around HTML â€ ags)\n    // https://www.w3.org/TR/html51/syntax.html#data-state\n    function stateData(char: string) {\n        if (char === '<') {\n            startNewTag();\n        }\n    }\n\n    // Called after a '<' is read from the Data state\n    // https://www.w3.org/TR/html51/syntax.html#tag-open-state\n    function stateTagOpen(char: string) {\n        if (char === '!') {\n            state = State.MarkupDeclarationOpenState;\n        } else if (char === '/') {\n            state = State.EndTagOpen;\n            currentTag = new CurrentTag({ ...currentTag, isClosing: true });\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else if (letterRe.test(char)) {\n            // tag name start (and no '/' read)\n            state = State.TagName;\n            currentTag = new CurrentTag({ ...currentTag, isOpening: true });\n        } else {\n            // Any other\n            state = State.Data;\n            currentTag = noCurrentTag;\n        }\n    }\n\n    // After a '<x', '</x' sequence is read (where 'x' is a letter character),\n    // this is to continue reading the tag name\n    // https://www.w3.org/TR/html51/syntax.html#tag-name-state\n    function stateTagName(char: string) {\n        if (whitespaceRe.test(char)) {\n            currentTag = new CurrentTag({\n                ...currentTag,\n                name: captureTagName(),\n            });\n            state = State.BeforeAttributeName;\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else if (char === '/') {\n            currentTag = new CurrentTag({\n                ...currentTag,\n                name: captureTagName(),\n            });\n            state = State.SelfClosingStartTag;\n        } else if (char === '>') {\n            currentTag = new CurrentTag({\n                ...currentTag,\n                name: captureTagName(),\n            });\n            emitTagAndPreviousTextNode(); // resets to Data state as well\n        } else if (!letterRe.test(char) && !digitRe.test(char) && char !== ':') {\n            // Anything else that does not form an html tag. Note: the colon\n            // character is accepted for XML namespaced tags\n            resetToDataState();\n        } else {\n            // continue reading tag name\n        }\n    }\n\n    // Called after the '/' is read from a '</' sequence\n    // https://www.w3.org/TR/html51/syntax.html#end-tag-open-state\n    function stateEndTagOpen(char: string) {\n        if (char === '>') {\n            // parse error. Encountered \"</>\". Skip it without treating as a tag\n            resetToDataState();\n        } else if (letterRe.test(char)) {\n            state = State.TagName;\n        } else {\n            // some other non-tag-like character, don't treat this as a tag\n            resetToDataState();\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#before-attribute-name-state\n    function stateBeforeAttributeName(char: string) {\n        if (whitespaceRe.test(char)) {\n            // stay in BeforeAttributeName state - continue reading chars\n        } else if (char === '/') {\n            state = State.SelfClosingStartTag;\n        } else if (char === '>') {\n            emitTagAndPreviousTextNode(); // resets to Data state as well\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else if (char === `=` || quoteRe.test(char) || controlCharsRe.test(char)) {\n            // \"Parse error\" characters that, according to the spec, should be\n            // appended to the attribute name, but we'll treat these characters\n            // as not forming a real HTML tag\n            resetToDataState();\n        } else {\n            // Any other char, start of a new attribute name\n            state = State.AttributeName;\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#attribute-name-state\n    function stateAttributeName(char: string) {\n        if (whitespaceRe.test(char)) {\n            state = State.AfterAttributeName;\n        } else if (char === '/') {\n            state = State.SelfClosingStartTag;\n        } else if (char === '=') {\n            state = State.BeforeAttributeValue;\n        } else if (char === '>') {\n            emitTagAndPreviousTextNode(); // resets to Data state as well\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else if (quoteRe.test(char)) {\n            // \"Parse error\" characters that, according to the spec, should be\n            // appended to the attribute name, but we'll treat these characters\n            // as not forming a real HTML tag\n            resetToDataState();\n        } else {\n            // anything else: continue reading attribute name\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#after-attribute-name-state\n    function stateAfterAttributeName(char: string) {\n        if (whitespaceRe.test(char)) {\n            // ignore the character - continue reading\n        } else if (char === '/') {\n            state = State.SelfClosingStartTag;\n        } else if (char === '=') {\n            state = State.BeforeAttributeValue;\n        } else if (char === '>') {\n            emitTagAndPreviousTextNode();\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else if (quoteRe.test(char)) {\n            // \"Parse error\" characters that, according to the spec, should be\n            // appended to the attribute name, but we'll treat these characters\n            // as not forming a real HTML tag\n            resetToDataState();\n        } else {\n            // Any other character, start a new attribute in the current tag\n            state = State.AttributeName;\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#before-attribute-value-state\n    function stateBeforeAttributeValue(char: string) {\n        if (whitespaceRe.test(char)) {\n            // ignore the character - continue reading\n        } else if (char === `\"`) {\n            state = State.AttributeValueDoubleQuoted;\n        } else if (char === `'`) {\n            state = State.AttributeValueSingleQuoted;\n        } else if (/[>=`]/.test(char)) {\n            // Invalid chars after an '=' for an attribute value, don't count\n            // the current tag as an HTML tag\n            resetToDataState();\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else {\n            // Any other character, consider it an unquoted attribute value\n            state = State.AttributeValueUnquoted;\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#attribute-value-double-quoted-state\n    function stateAttributeValueDoubleQuoted(char: string) {\n        if (char === `\"`) {\n            // end the current double-quoted attribute\n            state = State.AfterAttributeValueQuoted;\n        } else {\n            // consume the character as part of the double-quoted attribute value\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#attribute-value-single-quoted-state\n    function stateAttributeValueSingleQuoted(char: string) {\n        if (char === `'`) {\n            // end the current single-quoted attribute\n            state = State.AfterAttributeValueQuoted;\n        } else {\n            // consume the character as part of the double-quoted attribute value\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#attribute-value-unquoted-state\n    function stateAttributeValueUnquoted(char: string) {\n        if (whitespaceRe.test(char)) {\n            state = State.BeforeAttributeName;\n        } else if (char === '>') {\n            emitTagAndPreviousTextNode();\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else {\n            // Any other character, treat it as part of the attribute value\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#after-attribute-value-quoted-state\n    function stateAfterAttributeValueQuoted(char: string) {\n        if (whitespaceRe.test(char)) {\n            state = State.BeforeAttributeName;\n        } else if (char === '/') {\n            state = State.SelfClosingStartTag;\n        } else if (char === '>') {\n            emitTagAndPreviousTextNode();\n        } else if (char === '<') {\n            // start of another tag (ignore the previous, incomplete one)\n            startNewTag();\n        } else {\n            // Any other character, \"parse error\". Spec says to switch to the\n            // BeforeAttributeState and re-consume the character, as it may be\n            // the start of a new attribute name\n            state = State.BeforeAttributeName;\n            reconsumeCurrentCharacter();\n        }\n    }\n\n    // A '/' has just been read in the current tag (presumably for '/>'), and\n    // this handles the next character\n    // https://www.w3.org/TR/html51/syntax.html#self-closing-start-tag-state\n    function stateSelfClosingStartTag(char: string) {\n        if (char === '>') {\n            currentTag = new CurrentTag({ ...currentTag, isClosing: true });\n            emitTagAndPreviousTextNode(); // resets to Data state as well\n        } else {\n            state = State.BeforeAttributeName;\n        }\n    }\n\n    // https://www.w3.org/TR/html51/syntax.html#markup-declaration-open-state\n    // (HTML Comments or !DOCTYPE)\n    function stateMarkupDeclarationOpen(char: string) {\n        if (html.substr(charIdx, 2) === '--') {\n            // html comment\n            charIdx += 2; // \"consume\" characters\n            currentTag = new CurrentTag({ ...currentTag, type: 'comment' });\n            state = State.CommentStart;\n        } else if (html.substr(charIdx, 7).toUpperCase() === 'DOCTYPE') {\n            charIdx += 7; // \"consume\" characters\n            currentTag = new CurrentTag({ ...currentTag, type: 'doctype' });\n            state = State.Doctype;\n        } else {\n            // At this point, the spec specifies that the state machine should\n            // enter the \"bogus comment\" state, in which case any character(s)\n            // after the '<!' that were read should become an HTML comment up\n            // until the first '>' that is read (or EOF). Instead, we'll assume\n            // that a user just typed '<!' as part of text data\n            resetToDataState();\n        }\n    }\n\n    // Handles after the sequence '<!--' has been read\n    // https://www.w3.org/TR/html51/syntax.html#comment-start-state\n    function stateCommentStart(char: string) {\n        if (char === '-') {\n            // We've read the sequence '<!---' at this point (3 dashes)\n            state = State.CommentStartDash;\n        } else if (char === '>') {\n            // At this point, we'll assume the comment wasn't a real comment\n            // so we'll just emit it as data. We basically read the sequence\n            // '<!-->'\n            resetToDataState();\n        } else {\n            // Any other char, take it as part of the comment\n            state = State.Comment;\n        }\n    }\n\n    // We've read the sequence '<!---' at this point (3 dashes)\n    // https://www.w3.org/TR/html51/syntax.html#comment-start-dash-state\n    function stateCommentStartDash(char: string) {\n        if (char === '-') {\n            // We've read '<!----' (4 dashes) at this point\n            state = State.CommentEnd;\n        } else if (char === '>') {\n            // At this point, we'll assume the comment wasn't a real comment\n            // so we'll just emit it as data. We basically read the sequence\n            // '<!--->'\n            resetToDataState();\n        } else {\n            // Anything else, take it as a valid comment\n            state = State.Comment;\n        }\n    }\n\n    // Currently reading the comment's text (data)\n    // https://www.w3.org/TR/html51/syntax.html#comment-state\n    function stateComment(char: string) {\n        if (char === '-') {\n            state = State.CommentEndDash;\n        } else {\n            // Any other character, stay in the Comment state\n        }\n    }\n\n    // When we we've read the first dash inside a comment, it may signal the\n    // end of the comment if we read another dash\n    // https://www.w3.org/TR/html51/syntax.html#comment-end-dash-state\n    function stateCommentEndDash(char: string) {\n        if (char === '-') {\n            state = State.CommentEnd;\n        } else {\n            // Wasn't a dash, must still be part of the comment\n            state = State.Comment;\n        }\n    }\n\n    // After we've read two dashes inside a comment, it may signal the end of\n    // the comment if we then read a '>' char\n    // https://www.w3.org/TR/html51/syntax.html#comment-end-state\n    function stateCommentEnd(char: string) {\n        if (char === '>') {\n            emitTagAndPreviousTextNode();\n        } else if (char === '!') {\n            state = State.CommentEndBang;\n        } else if (char === '-') {\n            // A 3rd '-' has been read: stay in the CommentEnd state\n        } else {\n            // Anything else, switch back to the comment state since we didn't\n            // read the full \"end comment\" sequence (i.e. '-->')\n            state = State.Comment;\n        }\n    }\n\n    // We've read the sequence '--!' inside of a comment\n    // https://www.w3.org/TR/html51/syntax.html#comment-end-bang-state\n    function stateCommentEndBang(char: string) {\n        if (char === '-') {\n            // We read the sequence '--!-' inside of a comment. The last dash\n            // could signify that the comment is going to close\n            state = State.CommentEndDash;\n        } else if (char === '>') {\n            // End of comment with the sequence '--!>'\n            emitTagAndPreviousTextNode();\n        } else {\n            // The '--!' was not followed by a '>', continue reading the\n            // comment's text\n            state = State.Comment;\n        }\n    }\n\n    /**\n     * For DOCTYPES in particular, we don't care about the attributes. Just\n     * advance to the '>' character and emit the tag, unless we find a '<'\n     * character in which case we'll start a new tag.\n     *\n     * Example doctype tag:\n     *    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n     *\n     * Actual spec: https://www.w3.org/TR/html51/syntax.html#doctype-state\n     */\n    function stateDoctype(char: string) {\n        if (char === '>') {\n            emitTagAndPreviousTextNode();\n        } else if (char === '<') {\n            startNewTag();\n        } else {\n            // stay in the Doctype state\n        }\n    }\n\n    /**\n     * Resets the state back to the Data state, and removes the current tag.\n     *\n     * We'll generally run this function whenever a \"parse error\" is\n     * encountered, where the current tag that is being read no longer looks\n     * like a real HTML tag.\n     */\n    function resetToDataState() {\n        state = State.Data;\n        currentTag = noCurrentTag;\n    }\n\n    /**\n     * Starts a new HTML tag at the current index, ignoring any previous HTML\n     * tag that was being read.\n     *\n     * We'll generally run this function whenever we read a new '<' character,\n     * including when we read a '<' character inside of an HTML tag that we were\n     * previously reading.\n     */\n    function startNewTag() {\n        state = State.TagOpen;\n        currentTag = new CurrentTag({ idx: charIdx });\n    }\n\n    /**\n     * Once we've decided to emit an open tag, that means we can also emit the\n     * text node before it.\n     */\n    function emitTagAndPreviousTextNode() {\n        const textBeforeTag = html.slice(currentDataIdx, currentTag.idx);\n        if (textBeforeTag) {\n            // the html tag was the first element in the html string, or two\n            // tags next to each other, in which case we should not emit a text\n            // node\n            onText(textBeforeTag, currentDataIdx);\n        }\n\n        if (currentTag.type === 'comment') {\n            onComment(currentTag.idx);\n        } else if (currentTag.type === 'doctype') {\n            onDoctype(currentTag.idx);\n        } else {\n            if (currentTag.isOpening) {\n                onOpenTag(currentTag.name, currentTag.idx);\n            }\n            if (currentTag.isClosing) {\n                // note: self-closing tags will emit both opening and closing\n                onCloseTag(currentTag.name, currentTag.idx);\n            }\n        }\n\n        // Since we just emitted a tag, reset to the data state for the next char\n        resetToDataState();\n        currentDataIdx = charIdx + 1;\n    }\n\n    function emitText() {\n        const text = html.slice(currentDataIdx, charIdx);\n        onText(text, currentDataIdx);\n\n        currentDataIdx = charIdx + 1;\n    }\n\n    /**\n     * Captures the tag name from the start of the tag to the current character\n     * index, and converts it to lower case\n     */\n    function captureTagName() {\n        const startIdx = currentTag.idx + (currentTag.isClosing ? 2 : 1);\n        return html.slice(startIdx, charIdx).toLowerCase();\n    }\n\n    /**\n     * Causes the main loop to re-consume the current character, such as after\n     * encountering a \"parse error\" that changed state and needs to reconsume\n     * the same character in that new state.\n     */\n    function reconsumeCurrentCharacter() {\n        charIdx--;\n    }\n}\n\nclass CurrentTag {\n    readonly idx: number; // the index of the '<' in the html string\n    readonly type: 'tag' | 'comment' | 'doctype';\n    readonly name: string;\n    readonly isOpening: boolean; // true if it's an opening tag, OR a self-closing open tag\n    readonly isClosing: boolean; // true if it's a closing tag, OR a self-closing open tag\n\n    constructor(cfg: Partial<CurrentTag> = {}) {\n        this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n        this.type = cfg.type || 'tag';\n        this.name = cfg.name || '';\n        this.isOpening = !!cfg.isOpening;\n        this.isClosing = !!cfg.isClosing;\n    }\n}\n"]}