<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StringUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">dubbo-remoting-zookeeper</a> &gt; <a href="../index.html" class="el_bundle">dubbo-common</a> &gt; <a href="index.source.html" class="el_package">org.apache.dubbo.common.utils</a> &gt; <span class="el_source">StringUtils.java</span></div><h1>StringUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.dubbo.common.utils;

import org.apache.dubbo.common.Constants;
import org.apache.dubbo.common.io.UnsafeStringWriter;
import org.apache.dubbo.common.logger.Logger;
import org.apache.dubbo.common.logger.LoggerFactory;

import com.alibaba.fastjson.JSON;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * StringUtils
 */

public final class StringUtils {

    public static final String EMPTY = &quot;&quot;;
    public static final int INDEX_NOT_FOUND = -1;
<span class="nc" id="L44">    public static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

<span class="nc" id="L46">    private static final Logger logger = LoggerFactory.getLogger(StringUtils.class);</span>
<span class="nc" id="L47">    private static final Pattern KVP_PATTERN = Pattern.compile(&quot;([_.a-zA-Z0-9][-_.a-zA-Z0-9]*)[=](.*)&quot;); //key value pair pattern.</span>
<span class="nc" id="L48">    private static final Pattern INT_PATTERN = Pattern.compile(&quot;^\\d+$&quot;);</span>
    private static final int PAD_LIMIT = 8192;

    private StringUtils() {
    }

    /**
     * Gets a CharSequence length or {@code 0} if the CharSequence is
     * {@code null}.
     *
     * @param cs
     *            a CharSequence or {@code null}
     * @return CharSequence length or {@code 0} if the CharSequence is
     *         {@code null}.
     */
    public static int length(final CharSequence cs) {
<span class="nc bnc" id="L64" title="All 2 branches missed.">        return cs == null ? 0 : cs.length();</span>
    }

    /**
     * &lt;p&gt;Repeat a String {@code repeat} times to form a
     * new String.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, 2) = null
     * StringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;
     * StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;
     * StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;
     * StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to repeat, may be null
     * @param repeat  number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  {@code null} if null String input
     */
    public static String repeat(final String str, final int repeat) {
        // Performance tuned for 2.0 (JDK1.4)

<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L89">            return null;</span>
        }
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (repeat &lt;= 0) {</span>
<span class="nc" id="L92">            return EMPTY;</span>
        }
<span class="nc" id="L94">        final int inputLength = str.length();</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">        if (repeat == 1 || inputLength == 0) {</span>
<span class="nc" id="L96">            return str;</span>
        }
<span class="nc bnc" id="L98" title="All 4 branches missed.">        if (inputLength == 1 &amp;&amp; repeat &lt;= PAD_LIMIT) {</span>
<span class="nc" id="L99">            return repeat(str.charAt(0), repeat);</span>
        }

<span class="nc" id="L102">        final int outputLength = inputLength * repeat;</span>
<span class="nc bnc" id="L103" title="All 3 branches missed.">        switch (inputLength) {</span>
            case 1 :
<span class="nc" id="L105">                return repeat(str.charAt(0), repeat);</span>
            case 2 :
<span class="nc" id="L107">                final char ch0 = str.charAt(0);</span>
<span class="nc" id="L108">                final char ch1 = str.charAt(1);</span>
<span class="nc" id="L109">                final char[] output2 = new char[outputLength];</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">                for (int i = repeat * 2 - 2; i &gt;= 0; i--, i--) {</span>
<span class="nc" id="L111">                    output2[i] = ch0;</span>
<span class="nc" id="L112">                    output2[i + 1] = ch1;</span>
                }
<span class="nc" id="L114">                return new String(output2);</span>
            default :
<span class="nc" id="L116">                final StringBuilder buf = new StringBuilder(outputLength);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                for (int i = 0; i &lt; repeat; i++) {</span>
<span class="nc" id="L118">                    buf.append(str);</span>
                }
<span class="nc" id="L120">                return buf.toString();</span>
        }
    }

    /**
     * &lt;p&gt;Repeat a String {@code repeat} times to form a
     * new String, with a String separator injected each time. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, null, 2) = null
     * StringUtils.repeat(null, &quot;x&quot;, 2)  = null
     * StringUtils.repeat(&quot;&quot;, null, 0)   = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, &quot;&quot;, 2)     = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, &quot;x&quot;, 3)    = &quot;xxx&quot;
     * StringUtils.repeat(&quot;?&quot;, &quot;, &quot;, 3)  = &quot;?, ?, ?&quot;
     * &lt;/pre&gt;
     *
     * @param str        the String to repeat, may be null
     * @param separator  the String to inject, may be null
     * @param repeat     number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  {@code null} if null String input
     * @since 2.5
     */
    public static String repeat(final String str, final String separator, final int repeat) {
<span class="nc bnc" id="L145" title="All 4 branches missed.">        if(str == null || separator == null) {</span>
<span class="nc" id="L146">            return repeat(str, repeat);</span>
        }
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
<span class="nc" id="L149">        final String result = repeat(str + separator, repeat);</span>
<span class="nc" id="L150">        return removeEnd(result, separator);</span>
    }

    /**
     * &lt;p&gt;Removes a substring only if it is at the end of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} source string will return {@code null}.
     * An empty (&quot;&quot;) source string will return the empty string.
     * A {@code null} search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEnd(null, *)      = null
     * StringUtils.removeEnd(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeEnd(*, null)      = *
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  {@code null} if null String input
     */
    public static String removeEnd(final String str, final String remove) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (isAnyEmpty(str, remove)) {</span>
<span class="nc" id="L178">            return str;</span>
        }
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (str.endsWith(remove)) {</span>
<span class="nc" id="L181">            return str.substring(0, str.length() - remove.length());</span>
        }
<span class="nc" id="L183">        return str;</span>
    }

    /**
     * &lt;p&gt;Returns padding using the specified delimiter repeated
     * to a given length.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat('e', 0)  = &quot;&quot;
     * StringUtils.repeat('e', 3)  = &quot;eee&quot;
     * StringUtils.repeat('e', -2) = &quot;&quot;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note: this method doesn't not support padding with
     * &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_character&quot;&gt;Unicode Supplementary Characters&lt;/a&gt;
     * as they require a pair of {@code char}s to be represented.
     * If you are needing to support full I18N of your applications
     * consider using {@link #repeat(String, int)} instead.
     * &lt;/p&gt;
     *
     * @param ch  character to repeat
     * @param repeat  number of times to repeat char, negative treated as zero
     * @return String with repeated character
     * @see #repeat(String, int)
     */
    public static String repeat(final char ch, final int repeat) {
<span class="nc" id="L209">        final char[] buf = new char[repeat];</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (int i = repeat - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L211">            buf[i] = ch;</span>
        }
<span class="nc" id="L213">        return new String(buf);</span>
    }

    /**
     * &lt;p&gt;Strips any of a set of characters from the end of a String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} input String returns {@code null}.
     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is {@code null}, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripEnd(null, *)          = null
     * StringUtils.stripEnd(&quot;&quot;, *)            = &quot;&quot;
     * StringUtils.stripEnd(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
     * StringUtils.stripEnd(&quot;abc&quot;, null)      = &quot;abc&quot;
     * StringUtils.stripEnd(&quot;  abc&quot;, null)    = &quot;  abc&quot;
     * StringUtils.stripEnd(&quot;abc  &quot;, null)    = &quot;abc&quot;
     * StringUtils.stripEnd(&quot; abc &quot;, null)    = &quot; abc&quot;
     * StringUtils.stripEnd(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
     * StringUtils.stripEnd(&quot;120.00&quot;, &quot;.0&quot;)   = &quot;12&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the set of characters to remove, null treated as whitespace
     * @return the stripped String, {@code null} if null String input
     */
    public static String stripEnd(final String str, final String stripChars) {
        int end;
<span class="nc bnc" id="L243" title="All 4 branches missed.">        if (str == null || (end = str.length()) == 0) {</span>
<span class="nc" id="L244">            return str;</span>
        }

<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (stripChars == null) {</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">            while (end != 0 &amp;&amp; Character.isWhitespace(str.charAt(end - 1))) {</span>
<span class="nc" id="L249">                end--;</span>
            }
<span class="nc bnc" id="L251" title="All 2 branches missed.">        } else if (stripChars.isEmpty()) {</span>
<span class="nc" id="L252">            return str;</span>
        } else {
<span class="nc bnc" id="L254" title="All 4 branches missed.">            while (end != 0 &amp;&amp; stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {</span>
<span class="nc" id="L255">                end--;</span>
            }
        }
<span class="nc" id="L258">        return str.substring(0, end);</span>
    }

    /**
     * &lt;p&gt;Replaces all occurrences of a String within another String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *)        = null
     * StringUtils.replace(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replace(&quot;any&quot;, null, *)    = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, null)    = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;b&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zbz&quot;
     * &lt;/pre&gt;
     *
     * @see #replace(String text, String searchString, String replacement, int max)
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace it with, may be null
     * @return the text with any replacements processed,
     *  {@code null} if null String input
     */
    public static String replace(final String text, final String searchString, final String replacement) {
<span class="nc" id="L285">        return replace(text, searchString, replacement, -1);</span>
    }

    /**
     * &lt;p&gt;Replaces a String with another String inside a larger String,
     * for the first {@code max} values of the search String.&lt;/p&gt;
     *
     * &lt;p&gt;A {@code null} reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *, *)         = null
     * StringUtils.replace(&quot;&quot;, *, *, *)           = &quot;&quot;
     * StringUtils.replace(&quot;any&quot;, null, *, *)     = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, null, *)     = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *, *)       = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, *, 0)        = &quot;any&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, null, -1) = &quot;abaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;&quot;, -1)   = &quot;b&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 0)   = &quot;abaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 1)   = &quot;zbaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 2)   = &quot;zbza&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, -1)  = &quot;zbzz&quot;
     * &lt;/pre&gt;
     *
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace it with, may be null
     * @param max  maximum number of values to replace, or {@code -1} if no maximum
     * @return the text with any replacements processed,
     *  {@code null} if null String input
     */
    public static String replace(final String text, final String searchString, final String replacement, int max) {
<span class="nc bnc" id="L317" title="All 6 branches missed.">        if (isAnyEmpty(text, searchString) || replacement == null || max == 0) {</span>
<span class="nc" id="L318">            return text;</span>
        }
<span class="nc" id="L320">        int start = 0;</span>
<span class="nc" id="L321">        int end = text.indexOf(searchString, start);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (end == INDEX_NOT_FOUND) {</span>
<span class="nc" id="L323">            return text;</span>
        }
<span class="nc" id="L325">        final int replLength = searchString.length();</span>
<span class="nc" id="L326">        int increase = replacement.length() - replLength;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        increase = increase &lt; 0 ? 0 : increase;</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">        increase *= max &lt; 0 ? 16 : max &gt; 64 ? 64 : max;</span>
<span class="nc" id="L329">        final StringBuilder buf = new StringBuilder(text.length() + increase);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        while (end != INDEX_NOT_FOUND) {</span>
<span class="nc" id="L331">            buf.append(text.substring(start, end)).append(replacement);</span>
<span class="nc" id="L332">            start = end + replLength;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (--max == 0) {</span>
<span class="nc" id="L334">                break;</span>
            }
<span class="nc" id="L336">            end = text.indexOf(searchString, start);</span>
        }
<span class="nc" id="L338">        buf.append(text.substring(start));</span>
<span class="nc" id="L339">        return buf.toString();</span>
    }

    public static boolean isBlank(String str) {
<span class="nc" id="L343">        return isEmpty(str);</span>
    }

    /**
     * is empty string.
     *
     * @param str source string.
     * @return is empty.
     */
    public static boolean isEmpty(String str) {
<span class="nc bnc" id="L353" title="All 4 branches missed.">        return str == null || str.isEmpty();</span>
    }

    /**
     * &lt;p&gt;Checks if the strings contain empty or null elements. &lt;p/&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNoneEmpty(null)            = false
     * StringUtils.isNoneEmpty(&quot;&quot;)              = false
     * StringUtils.isNoneEmpty(&quot; &quot;)             = true
     * StringUtils.isNoneEmpty(&quot;abc&quot;)           = true
     * StringUtils.isNoneEmpty(&quot;abc&quot;, &quot;def&quot;)    = true
     * StringUtils.isNoneEmpty(&quot;abc&quot;, null)     = false
     * StringUtils.isNoneEmpty(&quot;abc&quot;, &quot;&quot;)       = false
     * StringUtils.isNoneEmpty(&quot;abc&quot;, &quot; &quot;)      = true
     * &lt;/pre&gt;
     *
     * @param ss the strings to check
     * @return {@code true} if all strings are not empty or null
     */
    public static boolean isNoneEmpty(final String... ss) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (ArrayUtils.isEmpty(ss)) {</span>
<span class="nc" id="L375">            return false;</span>
        }
<span class="nc bnc" id="L377" title="All 2 branches missed.">        for (final String s : ss){</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (isEmpty(s)) {</span>
<span class="nc" id="L379">                return false;</span>
            }
        }
<span class="nc" id="L382">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the strings contain at least on empty or null element. &lt;p/&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAnyEmpty(null)            = true
     * StringUtils.isAnyEmpty(&quot;&quot;)              = true
     * StringUtils.isAnyEmpty(&quot; &quot;)             = false
     * StringUtils.isAnyEmpty(&quot;abc&quot;)           = false
     * StringUtils.isAnyEmpty(&quot;abc&quot;, &quot;def&quot;)    = false
     * StringUtils.isAnyEmpty(&quot;abc&quot;, null)     = true
     * StringUtils.isAnyEmpty(&quot;abc&quot;, &quot;&quot;)       = true
     * StringUtils.isAnyEmpty(&quot;abc&quot;, &quot; &quot;)      = false
     * &lt;/pre&gt;
     *
     * @param ss the strings to check
     * @return {@code true} if at least one in the strings is empty or null
     */
    public static boolean isAnyEmpty(final String... ss) {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        return !isNoneEmpty(ss);</span>
    }

    /**
     * is not empty string.
     *
     * @param str source string.
     * @return is not empty.
     */
    public static boolean isNotEmpty(String str) {
<span class="nc bnc" id="L413" title="All 2 branches missed.">        return !isEmpty(str);</span>
    }

    /**
     * @param s1
     * @param s2
     * @return equals
     */
    public static boolean isEquals(String s1, String s2) {
<span class="nc bnc" id="L422" title="All 4 branches missed.">        if (s1 == null &amp;&amp; s2 == null) {</span>
<span class="nc" id="L423">            return true;</span>
        }
<span class="nc bnc" id="L425" title="All 4 branches missed.">        if (s1 == null || s2 == null) {</span>
<span class="nc" id="L426">            return false;</span>
        }
<span class="nc" id="L428">        return s1.equals(s2);</span>
    }

    /**
     * is integer string.
     *
     * @param str
     * @return is integer
     */
    public static boolean isInteger(String str) {
<span class="nc bnc" id="L438" title="All 4 branches missed.">        return isNotEmpty(str) &amp;&amp; INT_PATTERN.matcher(str).matches();</span>
    }

    public static int parseInteger(String str) {
<span class="nc bnc" id="L442" title="All 2 branches missed.">        return isInteger(str) ? Integer.parseInt(str) : 0;</span>
    }

    /**
     * Returns true if s is a legal Java identifier.&lt;p&gt;
     * &lt;a href=&quot;http://www.exampledepot.com/egs/java.lang/IsJavaId.html&quot;&gt;more info.&lt;/a&gt;
     */
    public static boolean isJavaIdentifier(String s) {
<span class="nc bnc" id="L450" title="All 4 branches missed.">        if (isEmpty(s) || !Character.isJavaIdentifierStart(s.charAt(0))) {</span>
<span class="nc" id="L451">            return false;</span>
        }
<span class="nc bnc" id="L453" title="All 2 branches missed.">        for (int i = 1; i &lt; s.length(); i++) {</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (!Character.isJavaIdentifierPart(s.charAt(i))) {</span>
<span class="nc" id="L455">                return false;</span>
            }
        }
<span class="nc" id="L458">        return true;</span>
    }

    public static boolean isContains(String values, String value) {
<span class="nc bnc" id="L462" title="All 4 branches missed.">        return isNotEmpty(values) &amp;&amp; isContains(Constants.COMMA_SPLIT_PATTERN.split(values), value);</span>
    }

    /**
     * @param values
     * @param value
     * @return contains
     */
    public static boolean isContains(String[] values, String value) {
<span class="nc bnc" id="L471" title="All 4 branches missed.">        if (isNotEmpty(value) &amp;&amp; ArrayUtils.isNotEmpty(values)) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            for (String v : values) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (value.equals(v)) {</span>
<span class="nc" id="L474">                    return true;</span>
                }
            }
        }
<span class="nc" id="L478">        return false;</span>
    }

    public static boolean isNumeric(String str) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L483">            return false;</span>
        }
<span class="nc" id="L485">        int sz = str.length();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">            if (!Character.isDigit(str.charAt(i))) {</span>
<span class="nc" id="L488">                return false;</span>
            }
        }
<span class="nc" id="L491">        return true;</span>
    }

    /**
     * @param e
     * @return string
     */
    public static String toString(Throwable e) {
<span class="nc" id="L499">        UnsafeStringWriter w = new UnsafeStringWriter();</span>
<span class="nc" id="L500">        PrintWriter p = new PrintWriter(w);</span>
<span class="nc" id="L501">        p.print(e.getClass().getName());</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (e.getMessage() != null) {</span>
<span class="nc" id="L503">            p.print(&quot;: &quot; + e.getMessage());</span>
        }
<span class="nc" id="L505">        p.println();</span>
        try {
<span class="nc" id="L507">            e.printStackTrace(p);</span>
<span class="nc" id="L508">            return w.toString();</span>
        } finally {
<span class="nc" id="L510">            p.close();</span>
        }
    }

    /**
     * @param msg
     * @param e
     * @return string
     */
    public static String toString(String msg, Throwable e) {
<span class="nc" id="L520">        UnsafeStringWriter w = new UnsafeStringWriter();</span>
<span class="nc" id="L521">        w.write(msg + &quot;\n&quot;);</span>
<span class="nc" id="L522">        PrintWriter p = new PrintWriter(w);</span>
        try {
<span class="nc" id="L524">            e.printStackTrace(p);</span>
<span class="nc" id="L525">            return w.toString();</span>
        } finally {
<span class="nc" id="L527">            p.close();</span>
        }
    }

    /**
     * translate.
     *
     * @param src  source string.
     * @param from src char table.
     * @param to   target char table.
     * @return String.
     */
    public static String translate(String src, String from, String to) {
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (isEmpty(src)) {</span>
<span class="nc" id="L541">            return src;</span>
        }
<span class="nc" id="L543">        StringBuilder sb = null;</span>
        int ix;
        char c;
<span class="nc bnc" id="L546" title="All 2 branches missed.">        for (int i = 0, len = src.length(); i &lt; len; i++) {</span>
<span class="nc" id="L547">            c = src.charAt(i);</span>
<span class="nc" id="L548">            ix = from.indexOf(c);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (ix == -1) {</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                if (sb != null) {</span>
<span class="nc" id="L551">                    sb.append(c);</span>
                }
            } else {
<span class="nc bnc" id="L554" title="All 2 branches missed.">                if (sb == null) {</span>
<span class="nc" id="L555">                    sb = new StringBuilder(len);</span>
<span class="nc" id="L556">                    sb.append(src, 0, i);</span>
                }
<span class="nc bnc" id="L558" title="All 2 branches missed.">                if (ix &lt; to.length()) {</span>
<span class="nc" id="L559">                    sb.append(to.charAt(ix));</span>
                }
            }
        }
<span class="nc bnc" id="L563" title="All 2 branches missed.">        return sb == null ? src : sb.toString();</span>
    }

    /**
     * split.
     *
     * @param ch char.
     * @return string array.
     */
    public static String[] split(String str, char ch) {
<span class="nc" id="L573">        List&lt;String&gt; list = null;</span>
        char c;
<span class="nc" id="L575">        int ix = 0, len = str.length();</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L577">            c = str.charAt(i);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (c == ch) {</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">                if (list == null) {</span>
<span class="nc" id="L580">                    list = new ArrayList&lt;String&gt;();</span>
                }
<span class="nc" id="L582">                list.add(str.substring(ix, i));</span>
<span class="nc" id="L583">                ix = i + 1;</span>
            }
        }
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (ix &gt; 0) {</span>
<span class="nc" id="L587">            list.add(str.substring(ix));</span>
        }
<span class="nc bnc" id="L589" title="All 2 branches missed.">        return list == null ? EMPTY_STRING_ARRAY : (String[]) list.toArray(EMPTY_STRING_ARRAY);</span>
    }

    /**
     * join string.
     *
     * @param array String array.
     * @return String.
     */
    public static String join(String[] array) {
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (ArrayUtils.isEmpty(array)) {</span>
<span class="nc" id="L600">            return EMPTY;</span>
        }
<span class="nc" id="L602">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">        for (String s : array) {</span>
<span class="nc" id="L604">            sb.append(s);</span>
        }
<span class="nc" id="L606">        return sb.toString();</span>
    }

    /**
     * join string like javascript.
     *
     * @param array String array.
     * @param split split
     * @return String.
     */
    public static String join(String[] array, char split) {
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (ArrayUtils.isEmpty(array)) {</span>
<span class="nc" id="L618">            return EMPTY;</span>
        }
<span class="nc" id="L620">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L623">                sb.append(split);</span>
            }
<span class="nc" id="L625">            sb.append(array[i]);</span>
        }
<span class="nc" id="L627">        return sb.toString();</span>
    }

    /**
     * join string like javascript.
     *
     * @param array String array.
     * @param split split
     * @return String.
     */
    public static String join(String[] array, String split) {
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (ArrayUtils.isEmpty(array)) {</span>
<span class="nc" id="L639">            return EMPTY;</span>
        }
<span class="nc" id="L641">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L644">                sb.append(split);</span>
            }
<span class="nc" id="L646">            sb.append(array[i]);</span>
        }
<span class="nc" id="L648">        return sb.toString();</span>
    }

    public static String join(Collection&lt;String&gt; coll, String split) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (CollectionUtils.isEmpty(coll)) {</span>
<span class="nc" id="L653">            return EMPTY;</span>
        }

<span class="nc" id="L656">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L657">        boolean isFirst = true;</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        for (String s : coll) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (isFirst) {</span>
<span class="nc" id="L660">                isFirst = false;</span>
            } else {
<span class="nc" id="L662">                sb.append(split);</span>
            }
<span class="nc" id="L664">            sb.append(s);</span>
<span class="nc" id="L665">        }</span>
<span class="nc" id="L666">        return sb.toString();</span>
    }

    /**
     * parse key-value pair.
     *
     * @param str           string.
     * @param itemSeparator item separator.
     * @return key-value map;
     */
    private static Map&lt;String, String&gt; parseKeyValuePair(String str, String itemSeparator) {
<span class="nc" id="L677">        String[] tmp = str.split(itemSeparator);</span>
<span class="nc" id="L678">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(tmp.length);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        for (int i = 0; i &lt; tmp.length; i++) {</span>
<span class="nc" id="L680">            Matcher matcher = KVP_PATTERN.matcher(tmp[i]);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (!matcher.matches()) {</span>
<span class="nc" id="L682">                continue;</span>
            }
<span class="nc" id="L684">            map.put(matcher.group(1), matcher.group(2));</span>
        }
<span class="nc" id="L686">        return map;</span>
    }

    public static String getQueryStringValue(String qs, String key) {
<span class="nc" id="L690">        Map&lt;String, String&gt; map = StringUtils.parseQueryString(qs);</span>
<span class="nc" id="L691">        return map.get(key);</span>
    }

    /**
     * parse query string to Parameters.
     *
     * @param qs query string.
     * @return Parameters instance.
     */
    public static Map&lt;String, String&gt; parseQueryString(String qs) {
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (isEmpty(qs)) {</span>
<span class="nc" id="L702">            return new HashMap&lt;String, String&gt;();</span>
        }
<span class="nc" id="L704">        return parseKeyValuePair(qs, &quot;\\&amp;&quot;);</span>
    }

    public static String getServiceKey(Map&lt;String, String&gt; ps) {
<span class="nc" id="L708">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L709">        String group = ps.get(Constants.GROUP_KEY);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (isNotEmpty(group)) {</span>
<span class="nc" id="L711">            buf.append(group).append(&quot;/&quot;);</span>
        }
<span class="nc" id="L713">        buf.append(ps.get(Constants.INTERFACE_KEY));</span>
<span class="nc" id="L714">        String version = ps.get(Constants.VERSION_KEY);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (isNotEmpty(group)) {</span>
<span class="nc" id="L716">            buf.append(&quot;:&quot;).append(version);</span>
        }
<span class="nc" id="L718">        return buf.toString();</span>
    }

    public static String toQueryString(Map&lt;String, String&gt; ps) {
<span class="nc" id="L722">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L723" title="All 4 branches missed.">        if (ps != null &amp;&amp; ps.size() &gt; 0) {</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            for (Map.Entry&lt;String, String&gt; entry : new TreeMap&lt;String, String&gt;(ps).entrySet()) {</span>
<span class="nc" id="L725">                String key = entry.getKey();</span>
<span class="nc" id="L726">                String value = entry.getValue();</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (isNoneEmpty(key, value)) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    if (buf.length() &gt; 0) {</span>
<span class="nc" id="L729">                        buf.append(&quot;&amp;&quot;);</span>
                    }
<span class="nc" id="L731">                    buf.append(key);</span>
<span class="nc" id="L732">                    buf.append(&quot;=&quot;);</span>
<span class="nc" id="L733">                    buf.append(value);</span>
                }
<span class="nc" id="L735">            }</span>
        }
<span class="nc" id="L737">        return buf.toString();</span>
    }

    public static String camelToSplitName(String camelName, String split) {
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (isEmpty(camelName)) {</span>
<span class="nc" id="L742">            return camelName;</span>
        }
<span class="nc" id="L744">        StringBuilder buf = null;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        for (int i = 0; i &lt; camelName.length(); i++) {</span>
<span class="nc" id="L746">            char ch = camelName.charAt(i);</span>
<span class="nc bnc" id="L747" title="All 4 branches missed.">            if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                if (buf == null) {</span>
<span class="nc" id="L749">                    buf = new StringBuilder();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L751">                        buf.append(camelName.substring(0, i));</span>
                    }
                }
<span class="nc bnc" id="L754" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L755">                    buf.append(split);</span>
                }
<span class="nc" id="L757">                buf.append(Character.toLowerCase(ch));</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            } else if (buf != null) {</span>
<span class="nc" id="L759">                buf.append(ch);</span>
            }
        }
<span class="nc bnc" id="L762" title="All 2 branches missed.">        return buf == null ? camelName : buf.toString();</span>
    }

    public static String toArgumentString(Object[] args) {
<span class="nc" id="L766">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">        for (Object arg : args) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            if (buf.length() &gt; 0) {</span>
<span class="nc" id="L769">                buf.append(Constants.COMMA_SEPARATOR);</span>
            }
<span class="nc bnc" id="L771" title="All 4 branches missed.">            if (arg == null || ReflectUtils.isPrimitives(arg.getClass())) {</span>
<span class="nc" id="L772">                buf.append(arg);</span>
            } else {
                try {
<span class="nc" id="L775">                    buf.append(JSON.toJSONString(arg));</span>
<span class="nc" id="L776">                } catch (Exception e) {</span>
<span class="nc" id="L777">                    logger.warn(e.getMessage(), e);</span>
<span class="nc" id="L778">                    buf.append(arg);</span>
<span class="nc" id="L779">                }</span>
            }
        }
<span class="nc" id="L782">        return buf.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>