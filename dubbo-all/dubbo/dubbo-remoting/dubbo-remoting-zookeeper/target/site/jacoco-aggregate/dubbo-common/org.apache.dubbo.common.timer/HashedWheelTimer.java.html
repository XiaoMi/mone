<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HashedWheelTimer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">dubbo-remoting-zookeeper</a> &gt; <a href="../index.html" class="el_bundle">dubbo-common</a> &gt; <a href="index.source.html" class="el_package">org.apache.dubbo.common.timer</a> &gt; <span class="el_source">HashedWheelTimer.java</span></div><h1>HashedWheelTimer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package org.apache.dubbo.common.timer;

import org.apache.dubbo.common.logger.Logger;
import org.apache.dubbo.common.logger.LoggerFactory;
import org.apache.dubbo.common.utils.ClassHelper;

import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicLong;

/**
 * A {@link Timer} optimized for approximated I/O timeout scheduling.
 *
 * &lt;h3&gt;Tick Duration&lt;/h3&gt;
 * &lt;p&gt;
 * As described with 'approximated', this timer does not execute the scheduled
 * {@link TimerTask} on time.  {@link HashedWheelTimer}, on every tick, will
 * check if there are any {@link TimerTask}s behind the schedule and execute
 * them.
 * &lt;p&gt;
 * You can increase or decrease the accuracy of the execution timing by
 * specifying smaller or larger tick duration in the constructor.  In most
 * network applications, I/O timeout does not need to be accurate.  Therefore,
 * the default tick duration is 100 milliseconds and you will not need to try
 * different configurations in most cases.
 *
 * &lt;h3&gt;Ticks per Wheel (Wheel Size)&lt;/h3&gt;
 * &lt;p&gt;
 * {@link HashedWheelTimer} maintains a data structure called 'wheel'.
 * To put simply, a wheel is a hash table of {@link TimerTask}s whose hash
 * function is 'dead line of the task'.  The default number of ticks per wheel
 * (i.e. the size of the wheel) is 512.  You could specify a larger value
 * if you are going to schedule a lot of timeouts.
 *
 * &lt;h3&gt;Do not create many instances.&lt;/h3&gt;
 * &lt;p&gt;
 * {@link HashedWheelTimer} creates a new thread whenever it is instantiated and
 * started.  Therefore, you should make sure to create only one instance and
 * share it across your application.  One of the common mistakes, that makes
 * your application unresponsive, is to create a new instance for every connection.
 *
 * &lt;h3&gt;Implementation Details&lt;/h3&gt;
 * &lt;p&gt;
 * {@link HashedWheelTimer} is based on
 * &lt;a href=&quot;http://cseweb.ucsd.edu/users/varghese/&quot;&gt;George Varghese&lt;/a&gt; and
 * Tony Lauck's paper,
 * &lt;a href=&quot;http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z&quot;&gt;'Hashed
 * and Hierarchical Timing Wheels: data structures to efficiently implement a
 * timer facility'&lt;/a&gt;.  More comprehensive slides are located
 * &lt;a href=&quot;http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt&quot;&gt;here&lt;/a&gt;.
 */
public class HashedWheelTimer implements Timer {

    /**
     * may be in spi?
     */
    public static final String NAME = &quot;hased&quot;;

<span class="nc" id="L82">    private static final Logger logger = LoggerFactory.getLogger(HashedWheelTimer.class);</span>

<span class="nc" id="L84">    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();</span>
<span class="nc" id="L85">    private static final AtomicBoolean WARNED_TOO_MANY_INSTANCES = new AtomicBoolean();</span>
    private static final int INSTANCE_COUNT_LIMIT = 64;
<span class="nc" id="L87">    private static final AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span>
<span class="nc" id="L88">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, &quot;workerState&quot;);</span>

<span class="nc" id="L90">    private final Worker worker = new Worker();</span>
    private final Thread workerThread;

    private static final int WORKER_STATE_INIT = 0;
    private static final int WORKER_STATE_STARTED = 1;
    private static final int WORKER_STATE_SHUTDOWN = 2;

    /**
     * 0 - init, 1 - started, 2 - shut down
     */
    @SuppressWarnings({&quot;unused&quot;, &quot;FieldMayBeFinal&quot;})
    private volatile int workerState;

    private final long tickDuration;
    private final HashedWheelBucket[] wheel;
    private final int mask;
<span class="nc" id="L106">    private final CountDownLatch startTimeInitialized = new CountDownLatch(1);</span>
<span class="nc" id="L107">    private final Queue&lt;HashedWheelTimeout&gt; timeouts = new LinkedBlockingQueue&lt;&gt;();</span>
<span class="nc" id="L108">    private final Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = new LinkedBlockingQueue&lt;&gt;();</span>
<span class="nc" id="L109">    private final AtomicLong pendingTimeouts = new AtomicLong(0);</span>
    private final long maxPendingTimeouts;

    private volatile long startTime;

    /**
     * Creates a new timer with the default thread factory
     * ({@link Executors#defaultThreadFactory()}), default tick duration, and
     * default number of ticks per wheel.
     */
    public HashedWheelTimer() {
<span class="nc" id="L120">        this(Executors.defaultThreadFactory());</span>
<span class="nc" id="L121">    }</span>

    /**
     * Creates a new timer with the default thread factory
     * ({@link Executors#defaultThreadFactory()}) and default number of ticks
     * per wheel.
     *
     * @param tickDuration the duration between tick
     * @param unit         the time unit of the {@code tickDuration}
     * @throws NullPointerException     if {@code unit} is {@code null}
     * @throws IllegalArgumentException if {@code tickDuration} is &amp;lt;= 0
     */
    public HashedWheelTimer(long tickDuration, TimeUnit unit) {
<span class="nc" id="L134">        this(Executors.defaultThreadFactory(), tickDuration, unit);</span>
<span class="nc" id="L135">    }</span>

    /**
     * Creates a new timer with the default thread factory
     * ({@link Executors#defaultThreadFactory()}).
     *
     * @param tickDuration  the duration between tick
     * @param unit          the time unit of the {@code tickDuration}
     * @param ticksPerWheel the size of the wheel
     * @throws NullPointerException     if {@code unit} is {@code null}
     * @throws IllegalArgumentException if either of {@code tickDuration} and {@code ticksPerWheel} is &amp;lt;= 0
     */
    public HashedWheelTimer(long tickDuration, TimeUnit unit, int ticksPerWheel) {
<span class="nc" id="L148">        this(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span>
<span class="nc" id="L149">    }</span>

    /**
     * Creates a new timer with the default tick duration and default number of
     * ticks per wheel.
     *
     * @param threadFactory a {@link ThreadFactory} that creates a
     *                      background {@link Thread} which is dedicated to
     *                      {@link TimerTask} execution.
     * @throws NullPointerException if {@code threadFactory} is {@code null}
     */
    public HashedWheelTimer(ThreadFactory threadFactory) {
<span class="nc" id="L161">        this(threadFactory, 100, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L162">    }</span>

    /**
     * Creates a new timer with the default number of ticks per wheel.
     *
     * @param threadFactory a {@link ThreadFactory} that creates a
     *                      background {@link Thread} which is dedicated to
     *                      {@link TimerTask} execution.
     * @param tickDuration  the duration between tick
     * @param unit          the time unit of the {@code tickDuration}
     * @throws NullPointerException     if either of {@code threadFactory} and {@code unit} is {@code null}
     * @throws IllegalArgumentException if {@code tickDuration} is &amp;lt;= 0
     */
    public HashedWheelTimer(
            ThreadFactory threadFactory, long tickDuration, TimeUnit unit) {
<span class="nc" id="L177">        this(threadFactory, tickDuration, unit, 512);</span>
<span class="nc" id="L178">    }</span>

    /**
     * Creates a new timer.
     *
     * @param threadFactory a {@link ThreadFactory} that creates a
     *                      background {@link Thread} which is dedicated to
     *                      {@link TimerTask} execution.
     * @param tickDuration  the duration between tick
     * @param unit          the time unit of the {@code tickDuration}
     * @param ticksPerWheel the size of the wheel
     * @throws NullPointerException     if either of {@code threadFactory} and {@code unit} is {@code null}
     * @throws IllegalArgumentException if either of {@code tickDuration} and {@code ticksPerWheel} is &amp;lt;= 0
     */
    public HashedWheelTimer(
            ThreadFactory threadFactory,
            long tickDuration, TimeUnit unit, int ticksPerWheel) {
<span class="nc" id="L195">        this(threadFactory, tickDuration, unit, ticksPerWheel, -1);</span>
<span class="nc" id="L196">    }</span>

    /**
     * Creates a new timer.
     *
     * @param threadFactory      a {@link ThreadFactory} that creates a
     *                           background {@link Thread} which is dedicated to
     *                           {@link TimerTask} execution.
     * @param tickDuration       the duration between tick
     * @param unit               the time unit of the {@code tickDuration}
     * @param ticksPerWheel      the size of the wheel
     * @param maxPendingTimeouts The maximum number of pending timeouts after which call to
     *                           {@code newTimeout} will result in
     *                           {@link java.util.concurrent.RejectedExecutionException}
     *                           being thrown. No maximum pending timeouts limit is assumed if
     *                           this value is 0 or negative.
     * @throws NullPointerException     if either of {@code threadFactory} and {@code unit} is {@code null}
     * @throws IllegalArgumentException if either of {@code tickDuration} and {@code ticksPerWheel} is &amp;lt;= 0
     */
    public HashedWheelTimer(
            ThreadFactory threadFactory,
            long tickDuration, TimeUnit unit, int ticksPerWheel,
<span class="nc" id="L218">            long maxPendingTimeouts) {</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (threadFactory == null) {</span>
<span class="nc" id="L221">            throw new NullPointerException(&quot;threadFactory&quot;);</span>
        }
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (unit == null) {</span>
<span class="nc" id="L224">            throw new NullPointerException(&quot;unit&quot;);</span>
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (tickDuration &lt;= 0) {</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(&quot;tickDuration must be greater than 0: &quot; + tickDuration);</span>
        }
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (ticksPerWheel &lt;= 0) {</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;ticksPerWheel must be greater than 0: &quot; + ticksPerWheel);</span>
        }

        // Normalize ticksPerWheel to power of two and initialize the wheel.
<span class="nc" id="L234">        wheel = createWheel(ticksPerWheel);</span>
<span class="nc" id="L235">        mask = wheel.length - 1;</span>

        // Convert tickDuration to nanos.
<span class="nc" id="L238">        this.tickDuration = unit.toNanos(tickDuration);</span>

        // Prevent overflow.
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (this.tickDuration &gt;= Long.MAX_VALUE / wheel.length) {</span>
<span class="nc" id="L242">            throw new IllegalArgumentException(String.format(</span>
                    &quot;tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d&quot;,
<span class="nc" id="L244">                    tickDuration, Long.MAX_VALUE / wheel.length));</span>
        }
<span class="nc" id="L246">        workerThread = threadFactory.newThread(worker);</span>

<span class="nc" id="L248">        this.maxPendingTimeouts = maxPendingTimeouts;</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">                WARNED_TOO_MANY_INSTANCES.compareAndSet(false, true)) {</span>
<span class="nc" id="L252">            reportTooManyInstances();</span>
        }
<span class="nc" id="L254">    }</span>

    @Override
    protected void finalize() throws Throwable {
        try {
<span class="nc" id="L259">            super.finalize();</span>
        } finally {
            // This object is going to be GCed and it is assumed the ship has sailed to do a proper shutdown. If
            // we have not yet shutdown then we want to make sure we decrement the active instance count.
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {</span>
<span class="nc" id="L264">                INSTANCE_COUNTER.decrementAndGet();</span>
            }
        }
<span class="nc" id="L267">    }</span>

    private static HashedWheelBucket[] createWheel(int ticksPerWheel) {
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (ticksPerWheel &lt;= 0) {</span>
<span class="nc" id="L271">            throw new IllegalArgumentException(</span>
                    &quot;ticksPerWheel must be greater than 0: &quot; + ticksPerWheel);
        }
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (ticksPerWheel &gt; 1073741824) {</span>
<span class="nc" id="L275">            throw new IllegalArgumentException(</span>
                    &quot;ticksPerWheel may not be greater than 2^30: &quot; + ticksPerWheel);
        }

<span class="nc" id="L279">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span>
<span class="nc" id="L280">        HashedWheelBucket[] wheel = new HashedWheelBucket[ticksPerWheel];</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (int i = 0; i &lt; wheel.length; i++) {</span>
<span class="nc" id="L282">            wheel[i] = new HashedWheelBucket();</span>
        }
<span class="nc" id="L284">        return wheel;</span>
    }

    private static int normalizeTicksPerWheel(int ticksPerWheel) {
<span class="nc" id="L288">        int normalizedTicksPerWheel = 1;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        while (normalizedTicksPerWheel &lt; ticksPerWheel) {</span>
<span class="nc" id="L290">            normalizedTicksPerWheel &lt;&lt;= 1;</span>
        }
<span class="nc" id="L292">        return normalizedTicksPerWheel;</span>
    }

    /**
     * Starts the background thread explicitly.  The background thread will
     * start automatically on demand even if you did not call this method.
     *
     * @throws IllegalStateException if this timer has been
     *                               {@linkplain #stop() stopped} already
     */
    public void start() {
<span class="nc bnc" id="L303" title="All 4 branches missed.">        switch (WORKER_STATE_UPDATER.get(this)) {</span>
            case WORKER_STATE_INIT:
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {</span>
<span class="nc" id="L306">                    workerThread.start();</span>
                }
                break;
            case WORKER_STATE_STARTED:
<span class="nc" id="L310">                break;</span>
            case WORKER_STATE_SHUTDOWN:
<span class="nc" id="L312">                throw new IllegalStateException(&quot;cannot be started once stopped&quot;);</span>
            default:
<span class="nc" id="L314">                throw new Error(&quot;Invalid WorkerState&quot;);</span>
        }

        // Wait until the startTime is initialized by the worker.
<span class="nc bnc" id="L318" title="All 2 branches missed.">        while (startTime == 0) {</span>
            try {
<span class="nc" id="L320">                startTimeInitialized.await();</span>
<span class="nc" id="L321">            } catch (InterruptedException ignore) {</span>
                // Ignore - it will be ready very soon.
<span class="nc" id="L323">            }</span>
        }
<span class="nc" id="L325">    }</span>

    @Override
    public Set&lt;Timeout&gt; stop() {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (Thread.currentThread() == workerThread) {</span>
<span class="nc" id="L330">            throw new IllegalStateException(</span>
<span class="nc" id="L331">                    HashedWheelTimer.class.getSimpleName() +</span>
                            &quot;.stop() cannot be called from &quot; +
<span class="nc" id="L333">                            TimerTask.class.getSimpleName());</span>
        }

<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (!WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {</span>
            // workerState can be 0 or 2 at this moment - let it always be 2.
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {</span>
<span class="nc" id="L339">                INSTANCE_COUNTER.decrementAndGet();</span>
            }

<span class="nc" id="L342">            return Collections.emptySet();</span>
        }

        try {
<span class="nc" id="L346">            boolean interrupted = false;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            while (workerThread.isAlive()) {</span>
<span class="nc" id="L348">                workerThread.interrupt();</span>
                try {
<span class="nc" id="L350">                    workerThread.join(100);</span>
<span class="nc" id="L351">                } catch (InterruptedException ignored) {</span>
<span class="nc" id="L352">                    interrupted = true;</span>
<span class="nc" id="L353">                }</span>
            }

<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (interrupted) {</span>
<span class="nc" id="L357">                Thread.currentThread().interrupt();</span>
            }
        } finally {
<span class="nc" id="L360">            INSTANCE_COUNTER.decrementAndGet();</span>
        }
<span class="nc" id="L362">        return worker.unprocessedTimeouts();</span>
    }

    @Override
    public boolean isStop() {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        return WORKER_STATE_SHUTDOWN == WORKER_STATE_UPDATER.get(this);</span>
    }

    @Override
    public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (task == null) {</span>
<span class="nc" id="L373">            throw new NullPointerException(&quot;task&quot;);</span>
        }
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (unit == null) {</span>
<span class="nc" id="L376">            throw new NullPointerException(&quot;unit&quot;);</span>
        }

<span class="nc" id="L379">        long pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span>

<span class="nc bnc" id="L381" title="All 4 branches missed.">        if (maxPendingTimeouts &gt; 0 &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) {</span>
<span class="nc" id="L382">            pendingTimeouts.decrementAndGet();</span>
<span class="nc" id="L383">            throw new RejectedExecutionException(&quot;Number of pending timeouts (&quot;</span>
                    + pendingTimeoutsCount + &quot;) is greater than or equal to maximum allowed pending &quot;
                    + &quot;timeouts (&quot; + maxPendingTimeouts + &quot;)&quot;);
        }

<span class="nc" id="L388">        start();</span>

        // Add the timeout to the timeout queue which will be processed on the next tick.
        // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.
<span class="nc" id="L392">        long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span>

        // Guard against overflow.
<span class="nc bnc" id="L395" title="All 4 branches missed.">        if (delay &gt; 0 &amp;&amp; deadline &lt; 0) {</span>
<span class="nc" id="L396">            deadline = Long.MAX_VALUE;</span>
        }
<span class="nc" id="L398">        HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);</span>
<span class="nc" id="L399">        timeouts.add(timeout);</span>
<span class="nc" id="L400">        return timeout;</span>
    }

    /**
     * Returns the number of pending timeouts of this {@link Timer}.
     */
    public long pendingTimeouts() {
<span class="nc" id="L407">        return pendingTimeouts.get();</span>
    }

    private static void reportTooManyInstances() {
<span class="nc" id="L411">        String resourceType = ClassHelper.simpleClassName(HashedWheelTimer.class);</span>
<span class="nc" id="L412">        logger.error(&quot;You are creating too many &quot; + resourceType + &quot; instances. &quot; +</span>
                resourceType + &quot; is a shared resource that must be reused across the JVM,&quot; +
                &quot;so that only a few instances are created.&quot;);
<span class="nc" id="L415">    }</span>

<span class="nc" id="L417">    private final class Worker implements Runnable {</span>
<span class="nc" id="L418">        private final Set&lt;Timeout&gt; unprocessedTimeouts = new HashSet&lt;Timeout&gt;();</span>

        private long tick;

        @Override
        public void run() {
            // Initialize the startTime.
<span class="nc" id="L425">            startTime = System.nanoTime();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (startTime == 0) {</span>
                // We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized.
<span class="nc" id="L428">                startTime = 1;</span>
            }

            // Notify the other threads waiting for the initialization at start().
<span class="nc" id="L432">            startTimeInitialized.countDown();</span>

            do {
<span class="nc" id="L435">                final long deadline = waitForNextTick();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (deadline &gt; 0) {</span>
<span class="nc" id="L437">                    int idx = (int) (tick &amp; mask);</span>
<span class="nc" id="L438">                    processCancelledTasks();</span>
<span class="nc" id="L439">                    HashedWheelBucket bucket =</span>
<span class="nc" id="L440">                            wheel[idx];</span>
<span class="nc" id="L441">                    transferTimeoutsToBuckets();</span>
<span class="nc" id="L442">                    bucket.expireTimeouts(deadline);</span>
<span class="nc" id="L443">                    tick++;</span>
                }
<span class="nc bnc" id="L445" title="All 2 branches missed.">            } while (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_STARTED);</span>

            // Fill the unprocessedTimeouts so we can return them from stop() method.
<span class="nc bnc" id="L448" title="All 2 branches missed.">            for (HashedWheelBucket bucket : wheel) {</span>
<span class="nc" id="L449">                bucket.clearTimeouts(unprocessedTimeouts);</span>
            }
            for (; ; ) {
<span class="nc" id="L452">                HashedWheelTimeout timeout = timeouts.poll();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                if (timeout == null) {</span>
<span class="nc" id="L454">                    break;</span>
                }
<span class="nc bnc" id="L456" title="All 2 branches missed.">                if (!timeout.isCancelled()) {</span>
<span class="nc" id="L457">                    unprocessedTimeouts.add(timeout);</span>
                }
<span class="nc" id="L459">            }</span>
<span class="nc" id="L460">            processCancelledTasks();</span>
<span class="nc" id="L461">        }</span>

        private void transferTimeoutsToBuckets() {
            // transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just
            // adds new timeouts in a loop.
<span class="nc bnc" id="L466" title="All 2 branches missed.">            for (int i = 0; i &lt; 100000; i++) {</span>
<span class="nc" id="L467">                HashedWheelTimeout timeout = timeouts.poll();</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                if (timeout == null) {</span>
                    // all processed
<span class="nc" id="L470">                    break;</span>
                }
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {</span>
                    // Was cancelled in the meantime.
<span class="nc" id="L474">                    continue;</span>
                }

<span class="nc" id="L477">                long calculated = timeout.deadline / tickDuration;</span>
<span class="nc" id="L478">                timeout.remainingRounds = (calculated - tick) / wheel.length;</span>

                // Ensure we don't schedule for past.
<span class="nc" id="L481">                final long ticks = Math.max(calculated, tick);</span>
<span class="nc" id="L482">                int stopIndex = (int) (ticks &amp; mask);</span>

<span class="nc" id="L484">                HashedWheelBucket bucket = wheel[stopIndex];</span>
<span class="nc" id="L485">                bucket.addTimeout(timeout);</span>
            }
<span class="nc" id="L487">        }</span>

        private void processCancelledTasks() {
            for (; ; ) {
<span class="nc" id="L491">                HashedWheelTimeout timeout = cancelledTimeouts.poll();</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                if (timeout == null) {</span>
                    // all processed
<span class="nc" id="L494">                    break;</span>
                }
                try {
<span class="nc" id="L497">                    timeout.remove();</span>
<span class="nc" id="L498">                } catch (Throwable t) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (logger.isWarnEnabled()) {</span>
<span class="nc" id="L500">                        logger.warn(&quot;An exception was thrown while process a cancellation task&quot;, t);</span>
                    }
<span class="nc" id="L502">                }</span>
<span class="nc" id="L503">            }</span>
<span class="nc" id="L504">        }</span>

        /**
         * calculate goal nanoTime from startTime and current tick number,
         * then wait until that goal has been reached.
         *
         * @return Long.MIN_VALUE if received a shutdown request,
         * current time otherwise (with Long.MIN_VALUE changed by +1)
         */
        private long waitForNextTick() {
<span class="nc" id="L514">            long deadline = tickDuration * (tick + 1);</span>

            for (; ; ) {
<span class="nc" id="L517">                final long currentTime = System.nanoTime() - startTime;</span>
<span class="nc" id="L518">                long sleepTimeMs = (deadline - currentTime + 999999) / 1000000;</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (sleepTimeMs &lt;= 0) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    if (currentTime == Long.MIN_VALUE) {</span>
<span class="nc" id="L522">                        return -Long.MAX_VALUE;</span>
                    } else {
<span class="nc" id="L524">                        return currentTime;</span>
                    }
                }
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (isWindows()) {</span>
<span class="nc" id="L528">                    sleepTimeMs = sleepTimeMs / 10 * 10;</span>
                }

                try {
<span class="nc" id="L532">                    Thread.sleep(sleepTimeMs);</span>
<span class="nc" id="L533">                } catch (InterruptedException ignored) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                    if (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_SHUTDOWN) {</span>
<span class="nc" id="L535">                        return Long.MIN_VALUE;</span>
                    }
<span class="nc" id="L537">                }</span>
<span class="nc" id="L538">            }</span>
        }

        Set&lt;Timeout&gt; unprocessedTimeouts() {
<span class="nc" id="L542">            return Collections.unmodifiableSet(unprocessedTimeouts);</span>
        }
    }

    private static final class HashedWheelTimeout implements Timeout {

        private static final int ST_INIT = 0;
        private static final int ST_CANCELLED = 1;
        private static final int ST_EXPIRED = 2;
<span class="nc" id="L551">        private static final AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span>
<span class="nc" id="L552">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, &quot;state&quot;);</span>

        private final HashedWheelTimer timer;
        private final TimerTask task;
        private final long deadline;

<span class="nc" id="L558">        @SuppressWarnings({&quot;unused&quot;, &quot;FieldMayBeFinal&quot;, &quot;RedundantFieldInitialization&quot;})</span>
        private volatile int state = ST_INIT;

        /**
         * RemainingRounds will be calculated and set by Worker.transferTimeoutsToBuckets() before the
         * HashedWheelTimeout will be added to the correct HashedWheelBucket.
         */
        long remainingRounds;

        /**
         * This will be used to chain timeouts in HashedWheelTimerBucket via a double-linked-list.
         * As only the workerThread will act on it there is no need for synchronization / volatile.
         */
        HashedWheelTimeout next;
        HashedWheelTimeout prev;

        /**
         * The bucket to which the timeout was added
         */
        HashedWheelBucket bucket;

<span class="nc" id="L579">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, long deadline) {</span>
<span class="nc" id="L580">            this.timer = timer;</span>
<span class="nc" id="L581">            this.task = task;</span>
<span class="nc" id="L582">            this.deadline = deadline;</span>
<span class="nc" id="L583">        }</span>

        @Override
        public Timer timer() {
<span class="nc" id="L587">            return timer;</span>
        }

        @Override
        public TimerTask task() {
<span class="nc" id="L592">            return task;</span>
        }

        @Override
        public boolean cancel() {
            // only update the state it will be removed from HashedWheelBucket on next tick.
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (!compareAndSetState(ST_INIT, ST_CANCELLED)) {</span>
<span class="nc" id="L599">                return false;</span>
            }
            // If a task should be canceled we put this to another queue which will be processed on each tick.
            // So this means that we will have a GC latency of max. 1 tick duration which is good enough. This way
            // we can make again use of our MpscLinkedQueue and so minimize the locking / overhead as much as possible.
<span class="nc" id="L604">            timer.cancelledTimeouts.add(this);</span>
<span class="nc" id="L605">            return true;</span>
        }

        void remove() {
<span class="nc" id="L609">            HashedWheelBucket bucket = this.bucket;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (bucket != null) {</span>
<span class="nc" id="L611">                bucket.remove(this);</span>
            } else {
<span class="nc" id="L613">                timer.pendingTimeouts.decrementAndGet();</span>
            }
<span class="nc" id="L615">        }</span>

        public boolean compareAndSetState(int expected, int state) {
<span class="nc" id="L618">            return STATE_UPDATER.compareAndSet(this, expected, state);</span>
        }

        public int state() {
<span class="nc" id="L622">            return state;</span>
        }

        @Override
        public boolean isCancelled() {
<span class="nc bnc" id="L627" title="All 2 branches missed.">            return state() == ST_CANCELLED;</span>
        }

        @Override
        public boolean isExpired() {
<span class="nc bnc" id="L632" title="All 2 branches missed.">            return state() == ST_EXPIRED;</span>
        }

        public void expire() {
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (!compareAndSetState(ST_INIT, ST_EXPIRED)) {</span>
<span class="nc" id="L637">                return;</span>
            }

            try {
<span class="nc" id="L641">                task.run(this);</span>
<span class="nc" id="L642">            } catch (Throwable t) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                if (logger.isWarnEnabled()) {</span>
<span class="nc" id="L644">                    logger.warn(&quot;An exception was thrown by &quot; + TimerTask.class.getSimpleName() + '.', t);</span>
                }
<span class="nc" id="L646">            }</span>
<span class="nc" id="L647">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L651">            final long currentTime = System.nanoTime();</span>
<span class="nc" id="L652">            long remaining = deadline - currentTime + timer.startTime;</span>
<span class="nc" id="L653">            String simpleClassName = ClassHelper.simpleClassName(this.getClass());</span>

<span class="nc" id="L655">            StringBuilder buf = new StringBuilder(192)</span>
<span class="nc" id="L656">                    .append(simpleClassName)</span>
<span class="nc" id="L657">                    .append('(')</span>
<span class="nc" id="L658">                    .append(&quot;deadline: &quot;);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (remaining &gt; 0) {</span>
<span class="nc" id="L660">                buf.append(remaining)</span>
<span class="nc" id="L661">                        .append(&quot; ns later&quot;);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            } else if (remaining &lt; 0) {</span>
<span class="nc" id="L663">                buf.append(-remaining)</span>
<span class="nc" id="L664">                        .append(&quot; ns ago&quot;);</span>
            } else {
<span class="nc" id="L666">                buf.append(&quot;now&quot;);</span>
            }

<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (isCancelled()) {</span>
<span class="nc" id="L670">                buf.append(&quot;, cancelled&quot;);</span>
            }

<span class="nc" id="L673">            return buf.append(&quot;, task: &quot;)</span>
<span class="nc" id="L674">                    .append(task())</span>
<span class="nc" id="L675">                    .append(')')</span>
<span class="nc" id="L676">                    .toString();</span>
        }
    }

    /**
     * Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy
     * removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no
     * extra object creation is needed.
     */
<span class="nc bnc" id="L685" title="All 2 branches missed.">    private static final class HashedWheelBucket {</span>

        /**
         * Used for the linked-list datastructure
         */
        private HashedWheelTimeout head;
        private HashedWheelTimeout tail;

        /**
         * Add {@link HashedWheelTimeout} to this bucket.
         */
        void addTimeout(HashedWheelTimeout timeout) {
<span class="nc bnc" id="L697" title="All 4 branches missed.">            assert timeout.bucket == null;</span>
<span class="nc" id="L698">            timeout.bucket = this;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">            if (head == null) {</span>
<span class="nc" id="L700">                head = tail = timeout;</span>
            } else {
<span class="nc" id="L702">                tail.next = timeout;</span>
<span class="nc" id="L703">                timeout.prev = tail;</span>
<span class="nc" id="L704">                tail = timeout;</span>
            }
<span class="nc" id="L706">        }</span>

        /**
         * Expire all {@link HashedWheelTimeout}s for the given {@code deadline}.
         */
        void expireTimeouts(long deadline) {
<span class="nc" id="L712">            HashedWheelTimeout timeout = head;</span>

            // process all timeouts
<span class="nc bnc" id="L715" title="All 2 branches missed.">            while (timeout != null) {</span>
<span class="nc" id="L716">                HashedWheelTimeout next = timeout.next;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if (timeout.remainingRounds &lt;= 0) {</span>
<span class="nc" id="L718">                    next = remove(timeout);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                    if (timeout.deadline &lt;= deadline) {</span>
<span class="nc" id="L720">                        timeout.expire();</span>
                    } else {
                        // The timeout was placed into a wrong slot. This should never happen.
<span class="nc" id="L723">                        throw new IllegalStateException(String.format(</span>
<span class="nc" id="L724">                                &quot;timeout.deadline (%d) &gt; deadline (%d)&quot;, timeout.deadline, deadline));</span>
                    }
<span class="nc bnc" id="L726" title="All 2 branches missed.">                } else if (timeout.isCancelled()) {</span>
<span class="nc" id="L727">                    next = remove(timeout);</span>
                } else {
<span class="nc" id="L729">                    timeout.remainingRounds--;</span>
                }
<span class="nc" id="L731">                timeout = next;</span>
<span class="nc" id="L732">            }</span>
<span class="nc" id="L733">        }</span>

        public HashedWheelTimeout remove(HashedWheelTimeout timeout) {
<span class="nc" id="L736">            HashedWheelTimeout next = timeout.next;</span>
            // remove timeout that was either processed or cancelled by updating the linked-list
<span class="nc bnc" id="L738" title="All 2 branches missed.">            if (timeout.prev != null) {</span>
<span class="nc" id="L739">                timeout.prev.next = next;</span>
            }
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (timeout.next != null) {</span>
<span class="nc" id="L742">                timeout.next.prev = timeout.prev;</span>
            }

<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (timeout == head) {</span>
                // if timeout is also the tail we need to adjust the entry too
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (timeout == tail) {</span>
<span class="nc" id="L748">                    tail = null;</span>
<span class="nc" id="L749">                    head = null;</span>
                } else {
<span class="nc" id="L751">                    head = next;</span>
                }
<span class="nc bnc" id="L753" title="All 2 branches missed.">            } else if (timeout == tail) {</span>
                // if the timeout is the tail modify the tail to be the prev node.
<span class="nc" id="L755">                tail = timeout.prev;</span>
            }
            // null out prev, next and bucket to allow for GC.
<span class="nc" id="L758">            timeout.prev = null;</span>
<span class="nc" id="L759">            timeout.next = null;</span>
<span class="nc" id="L760">            timeout.bucket = null;</span>
<span class="nc" id="L761">            timeout.timer.pendingTimeouts.decrementAndGet();</span>
<span class="nc" id="L762">            return next;</span>
        }

        /**
         * Clear this bucket and return all not expired / cancelled {@link Timeout}s.
         */
        void clearTimeouts(Set&lt;Timeout&gt; set) {
            for (; ; ) {
<span class="nc" id="L770">                HashedWheelTimeout timeout = pollTimeout();</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                if (timeout == null) {</span>
<span class="nc" id="L772">                    return;</span>
                }
<span class="nc bnc" id="L774" title="All 4 branches missed.">                if (timeout.isExpired() || timeout.isCancelled()) {</span>
<span class="nc" id="L775">                    continue;</span>
                }
<span class="nc" id="L777">                set.add(timeout);</span>
<span class="nc" id="L778">            }</span>
        }

        private HashedWheelTimeout pollTimeout() {
<span class="nc" id="L782">            HashedWheelTimeout head = this.head;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (head == null) {</span>
<span class="nc" id="L784">                return null;</span>
            }
<span class="nc" id="L786">            HashedWheelTimeout next = head.next;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (next == null) {</span>
<span class="nc" id="L788">                tail = this.head = null;</span>
            } else {
<span class="nc" id="L790">                this.head = next;</span>
<span class="nc" id="L791">                next.prev = null;</span>
            }

            // null out prev and next to allow for GC.
<span class="nc" id="L795">            head.next = null;</span>
<span class="nc" id="L796">            head.prev = null;</span>
<span class="nc" id="L797">            head.bucket = null;</span>
<span class="nc" id="L798">            return head;</span>
        }
    }

    private boolean isWindows() {
<span class="nc" id="L803">        return System.getProperty(&quot;os.name&quot;, &quot;&quot;).toLowerCase(Locale.US).contains(&quot;win&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>