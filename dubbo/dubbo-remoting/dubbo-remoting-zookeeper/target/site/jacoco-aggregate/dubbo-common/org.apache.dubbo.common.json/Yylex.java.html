<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Yylex.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">dubbo-remoting-zookeeper</a> &gt; <a href="../index.html" class="el_bundle">dubbo-common</a> &gt; <a href="index.source.html" class="el_package">org.apache.dubbo.common.json</a> &gt; <span class="el_source">Yylex.java</span></div><h1>Yylex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.dubbo.common.json;

/**
 * This class is a scanner generated by
 * &lt;a href=&quot;http://www.jflex.de/&quot;&gt;JFlex&lt;/a&gt; 1.4.3
 * on 7/3/10 3:12 AM from the specification file
 * &lt;tt&gt;/Users/qianlei/dev/proj/dubbo-1.1/dubbo.common/src/main/java/org.apache.dubbo/common/json/json.flex&lt;/tt&gt;
 */
@Deprecated
public class Yylex {

    /**
     * This character denotes the end of file
     */
    public static final int YYEOF = -1;
    /**
     * lexical states
     */
    public static final int STR2 = 4;
    public static final int STR1 = 2;
    public static final int YYINITIAL = 0;
    /**
     * initial size of the lookahead buffer
     */
    private static final int ZZ_BUFFERSIZE = 16384;
    /**
     * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
     * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
     * at the beginning of a line
     * l is of the form l = 2*k, k a non negative integer
     */
<span class="nc" id="L48">    private static final int ZZ_LEXSTATE[] = {</span>
            0, 0, 1, 1, 2, 2
    };

    /**
     * Translates characters to character classes
     */
    private static final String ZZ_CMAP_PACKED =
            &quot;\11\0\1\13\1\13\2\0\1\13\22\0\1\13\1\0\1\10\1\0&quot; +
                    &quot;\1\2\2\0\1\11\3\0\1\7\1\43\1\4\1\5\1\14\12\1&quot; +
                    &quot;\1\44\6\0\1\33\3\3\1\6\1\32\5\2\1\34\1\2\1\36&quot; +
                    &quot;\3\2\1\25\1\35\1\24\1\26\5\2\1\41\1\12\1\42\1\0&quot; +
                    &quot;\1\2\1\0\1\27\1\15\2\3\1\23\1\16\5\2\1\30\1\2&quot; +
                    &quot;\1\17\3\2\1\20\1\31\1\21\1\22\5\2\1\37\1\0\1\40&quot; +
                    &quot;\uff82\0&quot;;

    /**
     * Translates characters to character classes
     */
<span class="nc" id="L67">    private static final char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);</span>
    private static final String ZZ_ACTION_PACKED_0 =
            &quot;\3\0\1\1\1\2\1\3\1\1\1\4\1\5\1\6&quot; +
                    &quot;\6\3\1\7\1\10\1\11\1\12\1\13\1\14\1\15&quot; +
                    &quot;\1\16\1\0\1\15\3\0\6\3\1\17\1\20\1\21&quot; +
                    &quot;\1\22\1\23\1\24\1\25\1\26\1\0\1\27\2\30&quot; +
                    &quot;\1\0\6\3\1\0\1\3\1\31\1\32\1\3\1\0&quot; +
                    &quot;\1\33\1\0\1\34&quot;;
    /**
     * Translates DFA states to action switch labels.
     */
<span class="nc" id="L78">    private static final int[] ZZ_ACTION = zzUnpackAction();</span>
    private static final String ZZ_ROWMAP_PACKED_0 =
            &quot;\0\0\0\45\0\112\0\157\0\224\0\271\0\336\0\157&quot; +
                    &quot;\0\157\0\u0103\0\u0128\0\u014d\0\u0172\0\u0197\0\u01bc\0\u01e1&quot; +
                    &quot;\0\157\0\157\0\157\0\157\0\157\0\157\0\u0206\0\157&quot; +
                    &quot;\0\u022b\0\u0250\0\u0275\0\u029a\0\u02bf\0\u02e4\0\u0309\0\u032e&quot; +
                    &quot;\0\u0353\0\u0378\0\u039d\0\157\0\157\0\157\0\157\0\157&quot; +
                    &quot;\0\157\0\157\0\157\0\u03c2\0\157\0\u03e7\0\u040c\0\u040c&quot; +
                    &quot;\0\u0431\0\u0456\0\u047b\0\u04a0\0\u04c5\0\u04ea\0\u050f\0\u0534&quot; +
                    &quot;\0\271\0\271\0\u0559\0\u057e\0\271\0\u05a3\0\157&quot;;
    /**
     * Translates a state to a row index in the transition table
     */
<span class="nc" id="L91">    private static final int[] ZZ_ROWMAP = zzUnpackRowMap();</span>
    /**
     * The transition table of the DFA
     */
<span class="nc" id="L95">    private static final int ZZ_TRANS[] = {</span>
            3, 4, 5, 5, 6, 3, 5, 3, 7, 8,
            3, 9, 3, 5, 10, 11, 5, 12, 5, 5,
            13, 5, 5, 5, 5, 5, 14, 5, 5, 5,
            15, 16, 17, 18, 19, 20, 21, 22, 22, 22,
            22, 22, 22, 22, 22, 23, 22, 24, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 25, 25, 25, 25, 25, 25,
            25, 25, 25, 23, 26, 25, 25, 25, 25, 25,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            25, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, 4,
            -1, -1, -1, 27, 28, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 28, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, 5, 5, 5, -1,
            -1, 5, -1, -1, -1, -1, -1, -1, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, -1, -1, -1, -1,
            -1, -1, -1, 4, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            9, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 5, 5, 5,
            -1, -1, 5, -1, -1, -1, -1, -1, -1, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 29,
            5, 5, 5, 5, 5, 5, 5, -1, -1, -1,
            -1, -1, -1, -1, 5, 5, 5, -1, -1, 5,
            -1, -1, -1, -1, -1, -1, 5, 5, 5, 5,
            5, 30, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, -1, -1, -1, -1, -1, -1,
            -1, 5, 5, 5, -1, -1, 5, -1, -1, -1,
            -1, -1, -1, 5, 5, 5, 31, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, -1, -1, -1, -1, -1, -1, -1, 5, 5,
            5, -1, -1, 5, -1, -1, -1, -1, -1, -1,
            5, 5, 5, 5, 5, 5, 5, 5, 32, 5,
            5, 5, 5, 5, 5, 5, 5, 5, -1, -1,
            -1, -1, -1, -1, -1, 5, 5, 5, -1, -1,
            5, -1, -1, -1, -1, -1, -1, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 33, 5, 5, 5, -1, -1, -1, -1, -1,
            -1, -1, 5, 5, 5, -1, -1, 5, -1, -1,
            -1, -1, -1, -1, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 34, 5, 5, 5, 5, 5, 5,
            5, 5, -1, -1, -1, -1, -1, -1, 22, 22,
            22, 22, 22, 22, 22, 22, -1, 22, -1, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, -1, -1, -1, -1, -1,
            -1, -1, -1, 35, -1, 36, -1, 37, 38, 39,
            40, 41, 42, 43, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, 25, 25, 25, 25, 25, 25, 25, 25,
            25, -1, -1, 25, 25, 25, 25, 25, 25, 25,
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            25, 25, 25, 25, 25, 25, 25, 25, 25, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, 44, 36,
            -1, 37, 38, 39, 40, 41, 42, 43, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 45, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, 46, -1, -1, 47, -1, -1,
            47, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, 5, 5, 5, -1, -1, 5, -1, -1, -1,
            -1, -1, -1, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 48, 5, 5, 5, 5, 5,
            5, -1, -1, -1, -1, -1, -1, -1, 5, 5,
            5, -1, -1, 5, -1, -1, -1, -1, -1, -1,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 49, 5, 5, 5, 5, 5, 5, -1, -1,
            -1, -1, -1, -1, -1, 5, 5, 5, -1, -1,
            5, -1, -1, -1, -1, -1, -1, 5, 5, 5,
            5, 5, 50, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, -1, -1, -1, -1, -1,
            -1, -1, 5, 5, 5, -1, -1, 5, -1, -1,
            -1, -1, -1, -1, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 51, 5, 5, 5, 5, 5, 5,
            5, 5, -1, -1, -1, -1, -1, -1, -1, 5,
            5, 5, -1, -1, 5, -1, -1, -1, -1, -1,
            -1, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 52, 5, 5, -1,
            -1, -1, -1, -1, -1, -1, 5, 5, 5, -1,
            -1, 5, -1, -1, -1, -1, -1, -1, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 53, 5, 5, -1, -1, -1, -1,
            -1, -1, -1, 54, -1, 54, -1, -1, 54, -1,
            -1, -1, -1, -1, -1, 54, 54, -1, -1, -1,
            -1, 54, -1, -1, -1, 54, -1, -1, 54, 54,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            45, -1, -1, -1, -1, 28, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, 28, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 46, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, 5, 5, 5, -1, -1, 5,
            -1, -1, -1, -1, -1, -1, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 55, 5,
            5, 5, 5, 5, -1, -1, -1, -1, -1, -1,
            -1, 5, 5, 5, -1, -1, 5, -1, -1, -1,
            -1, -1, -1, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 56, 5, 5, 5, 5, 5,
            5, -1, -1, -1, -1, -1, -1, -1, 5, 5,
            5, -1, -1, 5, -1, -1, -1, -1, -1, -1,
            5, 5, 5, 5, 5, 5, 57, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, -1, -1,
            -1, -1, -1, -1, -1, 5, 5, 5, -1, -1,
            57, -1, -1, -1, -1, -1, -1, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, -1, -1, -1, -1, -1,
            -1, -1, 5, 5, 5, -1, -1, 5, -1, -1,
            -1, -1, -1, -1, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            58, 5, -1, -1, -1, -1, -1, -1, -1, 5,
            5, 5, -1, -1, 5, -1, -1, -1, -1, -1,
            -1, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 56, 5, 5, -1,
            -1, -1, -1, -1, -1, -1, 59, -1, 59, -1,
            -1, 59, -1, -1, -1, -1, -1, -1, 59, 59,
            -1, -1, -1, -1, 59, -1, -1, -1, 59, -1,
            -1, 59, 59, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, 5, 5, 5, -1, -1, 5, -1,
            -1, -1, -1, -1, -1, 5, 5, 5, 5, 5,
            5, 60, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, -1, -1, -1, -1, -1, -1, -1,
            5, 5, 5, -1, -1, 60, -1, -1, -1, -1,
            -1, -1, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            -1, -1, -1, -1, -1, -1, -1, 61, -1, 61,
            -1, -1, 61, -1, -1, -1, -1, -1, -1, 61,
            61, -1, -1, -1, -1, 61, -1, -1, -1, 61,
            -1, -1, 61, 61, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, 62, -1, 62, -1, -1, 62,
            -1, -1, -1, -1, -1, -1, 62, 62, -1, -1,
            -1, -1, 62, -1, -1, -1, 62, -1, -1, 62,
            62, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    };
    /* error codes */
    private static final int ZZ_UNKNOWN_ERROR = 0;
    private static final int ZZ_NO_MATCH = 1;
    private static final int ZZ_PUSHBACK_2BIG = 2;
    /* error messages for the codes above */
<span class="nc" id="L250">    private static final String ZZ_ERROR_MSG[] = {</span>
            &quot;Unkown internal scanner error&quot;,
            &quot;Error: could not match input&quot;,
            &quot;Error: pushback value was too large&quot;
    };
    private static final String ZZ_ATTRIBUTE_PACKED_0 =
            &quot;\3\0\1\11\3\1\2\11\7\1\6\11\1\1\1\11&quot; +
                    &quot;\1\0\1\1\3\0\6\1\10\11\1\0\1\11\2\1&quot; +
                    &quot;\1\0\6\1\1\0\4\1\1\0\1\1\1\0\1\11&quot;;
    /**
     * ZZ_ATTRIBUTE[aState] contains the attributes of state &lt;code&gt;aState&lt;/code&gt;
     */
<span class="nc" id="L262">    private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();</span>
    /**
     * the input device
     */
    private java.io.Reader zzReader;
    /**
     * the current state of the DFA
     */
    private int zzState;
    /**
     * the current lexical state
     */
<span class="nc" id="L274">    private int zzLexicalState = YYINITIAL;</span>
    /**
     * this buffer contains the current text to be matched and is
     * the source of the yytext() string
     */
<span class="nc" id="L279">    private char zzBuffer[] = new char[ZZ_BUFFERSIZE];</span>
    /**
     * the textposition at the last accepting state
     */
    private int zzMarkedPos;
    /**
     * the current text position in the buffer
     */
    private int zzCurrentPos;
    /**
     * startRead marks the beginning of the yytext() string in the buffer
     */
    private int zzStartRead;
    /**
     * endRead marks the last character in the buffer, that has been read
     * from input
     */
    private int zzEndRead;
    /**
     * zzAtEOF == true &lt;=&gt; the scanner is at the EOF
     */
    private boolean zzAtEOF;
    /**
     * denotes if the user-EOF-code has already been executed
     */
    //private boolean zzEOFDone;

  /* user code: */
    private StringBuffer sb;

    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param in the java.io.Reader to read input from.
     */
<span class="nc" id="L315">    Yylex(java.io.Reader in) {</span>
<span class="nc" id="L316">        this.zzReader = in;</span>
<span class="nc" id="L317">    }</span>

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param in the java.io.Inputstream to read input from.
     */
    Yylex(java.io.InputStream in) {
<span class="nc" id="L326">        this(new java.io.InputStreamReader(in));</span>
<span class="nc" id="L327">    }</span>

    private static int[] zzUnpackAction() {
<span class="nc" id="L330">        int[] result = new int[63];</span>
<span class="nc" id="L331">        int offset = 0;</span>
<span class="nc" id="L332">        offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);</span>
<span class="nc" id="L333">        return result;</span>
    }

    private static int zzUnpackAction(String packed, int offset, int[] result) {
<span class="nc" id="L337">        int i = 0;       /* index in packed string  */</span>
<span class="nc" id="L338">        int j = offset;  /* index in unpacked array */</span>
<span class="nc" id="L339">        int l = packed.length();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        while (i &lt; l) {</span>
<span class="nc" id="L341">            int count = packed.charAt(i++);</span>
<span class="nc" id="L342">            int value = packed.charAt(i++);</span>
            do {
<span class="nc" id="L344">                result[j++] = value;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            } while (--count &gt; 0);</span>
<span class="nc" id="L346">        }</span>
<span class="nc" id="L347">        return j;</span>
    }

    /** number of newlines encountered up to the start of the matched text */
    //private int yyline;

    /** the number of characters up to the start of the matched text */
    //private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    //private int yycolumn;

    /**
     * zzAtBOL == true &lt;=&gt; the scanner is currently at the beginning of a line
     */
    //private boolean zzAtBOL = true;
    private static int[] zzUnpackRowMap() {
<span class="nc" id="L367">        int[] result = new int[63];</span>
<span class="nc" id="L368">        int offset = 0;</span>
<span class="nc" id="L369">        offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);</span>
<span class="nc" id="L370">        return result;</span>
    }

    private static int zzUnpackRowMap(String packed, int offset, int[] result) {
<span class="nc" id="L374">        int i = 0;  /* index in packed string  */</span>
<span class="nc" id="L375">        int j = offset;  /* index in unpacked array */</span>
<span class="nc" id="L376">        int l = packed.length();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        while (i &lt; l) {</span>
<span class="nc" id="L378">            int high = packed.charAt(i++) &lt;&lt; 16;</span>
<span class="nc" id="L379">            result[j++] = high | packed.charAt(i++);</span>
<span class="nc" id="L380">        }</span>
<span class="nc" id="L381">        return j;</span>
    }

    private static int[] zzUnpackAttribute() {
<span class="nc" id="L385">        int[] result = new int[63];</span>
<span class="nc" id="L386">        int offset = 0;</span>
<span class="nc" id="L387">        offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);</span>
<span class="nc" id="L388">        return result;</span>
    }

    private static int zzUnpackAttribute(String packed, int offset, int[] result) {
<span class="nc" id="L392">        int i = 0;       /* index in packed string  */</span>
<span class="nc" id="L393">        int j = offset;  /* index in unpacked array */</span>
<span class="nc" id="L394">        int l = packed.length();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        while (i &lt; l) {</span>
<span class="nc" id="L396">            int count = packed.charAt(i++);</span>
<span class="nc" id="L397">            int value = packed.charAt(i++);</span>
            do {
<span class="nc" id="L399">                result[j++] = value;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            } while (--count &gt; 0);</span>
<span class="nc" id="L401">        }</span>
<span class="nc" id="L402">        return j;</span>
    }

    /**
     * Unpacks the compressed character translation table.
     *
     * @param packed the packed character translation table
     * @return the unpacked character translation table
     */
    private static char[] zzUnpackCMap(String packed) {
<span class="nc" id="L412">        char[] map = new char[0x10000];</span>
<span class="nc" id="L413">        int i = 0;  /* index in packed string  */</span>
<span class="nc" id="L414">        int j = 0;  /* index in unpacked array */</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        while (i &lt; 122) {</span>
<span class="nc" id="L416">            int count = packed.charAt(i++);</span>
<span class="nc" id="L417">            char value = packed.charAt(i++);</span>
            do {
<span class="nc" id="L419">                map[j++] = value;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            } while (--count &gt; 0);</span>
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">        return map;</span>
    }


    /**
     * Refills the input buffer.
     *
     * @return &lt;code&gt;false&lt;/code&gt;, iff there was new input.
     * @throws java.io.IOException if any I/O-Error occurs
     */
    private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (zzStartRead &gt; 0) {</span>
<span class="nc" id="L436">            System.arraycopy(zzBuffer, zzStartRead,</span>
                    zzBuffer, 0,
                    zzEndRead - zzStartRead);

      /* translate stored positions */
<span class="nc" id="L441">            zzEndRead -= zzStartRead;</span>
<span class="nc" id="L442">            zzCurrentPos -= zzStartRead;</span>
<span class="nc" id="L443">            zzMarkedPos -= zzStartRead;</span>
<span class="nc" id="L444">            zzStartRead = 0;</span>
        }

    /* is the buffer big enough? */
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (zzCurrentPos &gt;= zzBuffer.length) {</span>
      /* if not: blow it up */
<span class="nc" id="L450">            char newBuffer[] = new char[zzCurrentPos * 2];</span>
<span class="nc" id="L451">            System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);</span>
<span class="nc" id="L452">            zzBuffer = newBuffer;</span>
        }

    /* finally: fill the buffer with new input */
<span class="nc" id="L456">        int numRead = zzReader.read(zzBuffer, zzEndRead,</span>
                zzBuffer.length - zzEndRead);

<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (numRead &gt; 0) {</span>
<span class="nc" id="L460">            zzEndRead += numRead;</span>
<span class="nc" id="L461">            return false;</span>
        }
        // unlikely but not impossible: read 0 characters, but not at end of stream
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (numRead == 0) {</span>
<span class="nc" id="L465">            int c = zzReader.read();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (c == -1) {</span>
<span class="nc" id="L467">                return true;</span>
            } else {
<span class="nc" id="L469">                zzBuffer[zzEndRead++] = (char) c;</span>
<span class="nc" id="L470">                return false;</span>
            }
        }

        // numRead &lt; 0
<span class="nc" id="L475">        return true;</span>
    }


    /**
     * Closes the input stream.
     */
    public final void yyclose() throws java.io.IOException {
<span class="nc" id="L483">        zzAtEOF = true;            /* indicate end of file */</span>
<span class="nc" id="L484">        zzEndRead = zzStartRead;  /* invalidate buffer    */</span>

<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (zzReader != null) {</span>
<span class="nc" id="L487">            zzReader.close();</span>
        }
<span class="nc" id="L489">    }</span>


    /**
     * Resets the scanner to read from a new input stream.
     * Does not close the old reader.
     * &lt;p&gt;
     * All internal variables are reset, the old input stream
     * &lt;b&gt;cannot&lt;/b&gt; be reused (internal buffer is discarded and lost).
     * Lexical state is set to &lt;tt&gt;ZZ_INITIAL&lt;/tt&gt;.
     *
     * @param reader the new input stream
     */
    public final void yyreset(java.io.Reader reader) {
<span class="nc" id="L503">        zzReader = reader;</span>
        //zzAtBOL  = true;
<span class="nc" id="L505">        zzAtEOF = false;</span>
        //zzEOFDone = false;
<span class="nc" id="L507">        zzEndRead = zzStartRead = 0;</span>
<span class="nc" id="L508">        zzCurrentPos = zzMarkedPos = 0;</span>
        //yyline = yychar = yycolumn = 0;
<span class="nc" id="L510">        zzLexicalState = YYINITIAL;</span>
<span class="nc" id="L511">    }</span>


    /**
     * Returns the current lexical state.
     */
    public final int yystate() {
<span class="nc" id="L518">        return zzLexicalState;</span>
    }


    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    public final void yybegin(int newState) {
<span class="nc" id="L528">        zzLexicalState = newState;</span>
<span class="nc" id="L529">    }</span>


    /**
     * Returns the text matched by the current regular expression.
     */
    public final String yytext() {
<span class="nc" id="L536">        return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);</span>
    }


    /**
     * Returns the character at position &lt;tt&gt;pos&lt;/tt&gt; from the
     * matched text.
     * &lt;p&gt;
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     *            A value from 0 to yylength()-1.
     * @return the character at position pos
     */
    public final char yycharat(int pos) {
<span class="nc" id="L551">        return zzBuffer[zzStartRead + pos];</span>
    }


    /**
     * Returns the length of the matched text region.
     */
    public final int yylength() {
<span class="nc" id="L559">        return zzMarkedPos - zzStartRead;</span>
    }


    /**
     * Reports an error that occured while scanning.
     * &lt;p&gt;
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that &quot;Can't Possibly Happen&quot;.
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     * &lt;p&gt;
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param errorCode the code of the errormessage to display
     */
    private void zzScanError(int errorCode) {
        String message;
        try {
<span class="nc" id="L580">            message = ZZ_ERROR_MSG[errorCode];</span>
<span class="nc" id="L581">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L582">            message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];</span>
<span class="nc" id="L583">        }</span>

<span class="nc" id="L585">        throw new Error(message);</span>
    }


    /**
     * Pushes the specified amount of characters back into the input stream.
     * &lt;p&gt;
     * They will be read again by then next call of the scanning method
     *
     * @param number the number of characters to be read again.
     *               This number must not be greater than yylength()!
     */
    public void yypushback(int number) {
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (number &gt; yylength()) {</span>
<span class="nc" id="L599">            zzScanError(ZZ_PUSHBACK_2BIG);</span>
        }

<span class="nc" id="L602">        zzMarkedPos -= number;</span>
<span class="nc" id="L603">    }</span>


    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return the next token
     * @throws java.io.IOException if any I/O-Error occurs
     */
    public JSONToken yylex() throws java.io.IOException, ParseException {
        int zzInput;
        int zzAction;

        // cached fields:
        int zzCurrentPosL;
        int zzMarkedPosL;
<span class="nc" id="L620">        int zzEndReadL = zzEndRead;</span>
<span class="nc" id="L621">        char[] zzBufferL = zzBuffer;</span>
<span class="nc" id="L622">        char[] zzCMapL = ZZ_CMAP;</span>

<span class="nc" id="L624">        int[] zzTransL = ZZ_TRANS;</span>
<span class="nc" id="L625">        int[] zzRowMapL = ZZ_ROWMAP;</span>
<span class="nc" id="L626">        int[] zzAttrL = ZZ_ATTRIBUTE;</span>

        while (true) {
<span class="nc" id="L629">            zzMarkedPosL = zzMarkedPos;</span>

<span class="nc" id="L631">            zzAction = -1;</span>

<span class="nc" id="L633">            zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;</span>

<span class="nc" id="L635">            zzState = ZZ_LEXSTATE[zzLexicalState];</span>


            zzForAction:
            {
                while (true) {

<span class="nc bnc" id="L642" title="All 2 branches missed.">                    if (zzCurrentPosL &lt; zzEndReadL) {</span>
<span class="nc" id="L643">                        zzInput = zzBufferL[zzCurrentPosL++];</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                    } else if (zzAtEOF) {</span>
<span class="nc" id="L645">                        zzInput = YYEOF;</span>
<span class="nc" id="L646">                        break zzForAction;</span>
                    } else {
                        // store back cached positions
<span class="nc" id="L649">                        zzCurrentPos = zzCurrentPosL;</span>
<span class="nc" id="L650">                        zzMarkedPos = zzMarkedPosL;</span>
<span class="nc" id="L651">                        boolean eof = zzRefill();</span>
                        // get translated positions and possibly new buffer
<span class="nc" id="L653">                        zzCurrentPosL = zzCurrentPos;</span>
<span class="nc" id="L654">                        zzMarkedPosL = zzMarkedPos;</span>
<span class="nc" id="L655">                        zzBufferL = zzBuffer;</span>
<span class="nc" id="L656">                        zzEndReadL = zzEndRead;</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                        if (eof) {</span>
<span class="nc" id="L658">                            zzInput = YYEOF;</span>
<span class="nc" id="L659">                            break zzForAction;</span>
                        } else {
<span class="nc" id="L661">                            zzInput = zzBufferL[zzCurrentPosL++];</span>
                        }
                    }
<span class="nc" id="L664">                    int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                    if (zzNext == -1) {</span>
<span class="nc" id="L666">                        break zzForAction;</span>
                    }
<span class="nc" id="L668">                    zzState = zzNext;</span>

<span class="nc" id="L670">                    int zzAttributes = zzAttrL[zzState];</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                    if ((zzAttributes &amp; 1) == 1) {</span>
<span class="nc" id="L672">                        zzAction = zzState;</span>
<span class="nc" id="L673">                        zzMarkedPosL = zzCurrentPosL;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                        if ((zzAttributes &amp; 8) == 8) {</span>
<span class="nc" id="L675">                            break zzForAction;</span>
                        }
                    }

<span class="nc" id="L679">                }</span>
            }

            // store back cached position
<span class="nc" id="L683">            zzMarkedPos = zzMarkedPosL;</span>

<span class="nc bnc" id="L685" title="All 58 branches missed.">            switch (zzAction &lt; 0 ? zzAction : ZZ_ACTION[zzAction]) {</span>
                case 25: {
<span class="nc" id="L687">                    return new JSONToken(JSONToken.NULL, null);</span>
                }
                case 29:
<span class="nc" id="L690">                    break;</span>
                case 13: {
<span class="nc" id="L692">                    sb.append(yytext());</span>
                }
                case 30:
<span class="nc" id="L695">                    break;</span>
                case 18: {
<span class="nc" id="L697">                    sb.append('\b');</span>
                }
                case 31:
<span class="nc" id="L700">                    break;</span>
                case 9: {
<span class="nc" id="L702">                    return new JSONToken(JSONToken.LSQUARE);</span>
                }
                case 32:
<span class="nc" id="L705">                    break;</span>
                case 2: {
<span class="nc" id="L707">                    Long val = Long.valueOf(yytext());</span>
<span class="nc" id="L708">                    return new JSONToken(JSONToken.INT, val);</span>
                }
                case 33:
<span class="nc" id="L711">                    break;</span>
                case 16: {
<span class="nc" id="L713">                    sb.append('\\');</span>
                }
                case 34:
<span class="nc" id="L716">                    break;</span>
                case 8: {
<span class="nc" id="L718">                    return new JSONToken(JSONToken.RBRACE);</span>
                }
                case 35:
<span class="nc" id="L721">                    break;</span>
                case 26: {
<span class="nc" id="L723">                    return new JSONToken(JSONToken.BOOL, Boolean.TRUE);</span>
                }
                case 36:
<span class="nc" id="L726">                    break;</span>
                case 23: {
<span class="nc" id="L728">                    sb.append('\'');</span>
                }
                case 37:
<span class="nc" id="L731">                    break;</span>
                case 5: {
<span class="nc" id="L733">                    sb = new StringBuffer();</span>
<span class="nc" id="L734">                    yybegin(STR2);</span>
                }
                case 38:
<span class="nc" id="L737">                    break;</span>
                case 27: {
<span class="nc" id="L739">                    return new JSONToken(JSONToken.BOOL, Boolean.FALSE);</span>
                }
                case 39:
<span class="nc" id="L742">                    break;</span>
                case 12: {
<span class="nc" id="L744">                    return new JSONToken(JSONToken.COLON);</span>
                }
                case 40:
<span class="nc" id="L747">                    break;</span>
                case 21: {
<span class="nc" id="L749">                    sb.append('\r');</span>
                }
                case 41:
<span class="nc" id="L752">                    break;</span>
                case 3: {
<span class="nc" id="L754">                    return new JSONToken(JSONToken.IDENT, yytext());</span>
                }
                case 42:
<span class="nc" id="L757">                    break;</span>
                case 28: {
                    try {
<span class="nc" id="L760">                        sb.append((char) Integer.parseInt(yytext().substring(2), 16));</span>
<span class="nc" id="L761">                    } catch (Exception e) {</span>
<span class="nc" id="L762">                        throw new ParseException(e.getMessage());</span>
<span class="nc" id="L763">                    }</span>
                }
                case 43:
<span class="nc" id="L766">                    break;</span>
                case 10: {
<span class="nc" id="L768">                    return new JSONToken(JSONToken.RSQUARE);</span>
                }
                case 44:
<span class="nc" id="L771">                    break;</span>
                case 17: {
<span class="nc" id="L773">                    sb.append('/');</span>
                }
                case 45:
<span class="nc" id="L776">                    break;</span>
                case 11: {
<span class="nc" id="L778">                    return new JSONToken(JSONToken.COMMA);</span>
                }
                case 46:
<span class="nc" id="L781">                    break;</span>
                case 15: {
<span class="nc" id="L783">                    sb.append('&quot;');</span>
                }
                case 47:
<span class="nc" id="L786">                    break;</span>
                case 24: {
<span class="nc" id="L788">                    Double val = Double.valueOf(yytext());</span>
<span class="nc" id="L789">                    return new JSONToken(JSONToken.FLOAT, val);</span>
                }
                case 48:
<span class="nc" id="L792">                    break;</span>
                case 1: {
<span class="nc" id="L794">                    throw new ParseException(&quot;Unexpected char [&quot; + yytext() + &quot;]&quot;);</span>
                }
                case 49:
<span class="nc" id="L797">                    break;</span>
                case 19: {
<span class="nc" id="L799">                    sb.append('\f');</span>
                }
                case 50:
<span class="nc" id="L802">                    break;</span>
                case 7: {
<span class="nc" id="L804">                    return new JSONToken(JSONToken.LBRACE);</span>
                }
                case 51:
<span class="nc" id="L807">                    break;</span>
                case 14: {
<span class="nc" id="L809">                    yybegin(YYINITIAL);</span>
<span class="nc" id="L810">                    return new JSONToken(JSONToken.STRING, sb.toString());</span>
                }
                case 52:
<span class="nc" id="L813">                    break;</span>
                case 22: {
<span class="nc" id="L815">                    sb.append('\t');</span>
                }
                case 53:
<span class="nc" id="L818">                    break;</span>
                case 4: {
<span class="nc" id="L820">                    sb = new StringBuffer();</span>
<span class="nc" id="L821">                    yybegin(STR1);</span>
                }
                case 54:
<span class="nc" id="L824">                    break;</span>
                case 20: {
<span class="nc" id="L826">                    sb.append('\n');</span>
                }
                case 55:
<span class="nc" id="L829">                    break;</span>
                case 6: {
                }
                case 56:
<span class="nc" id="L833">                    break;</span>
                default:
<span class="nc bnc" id="L835" title="All 4 branches missed.">                    if (zzInput == YYEOF &amp;&amp; zzStartRead == zzCurrentPos) {</span>
<span class="nc" id="L836">                        zzAtEOF = true;</span>
<span class="nc" id="L837">                        return null;</span>
                    } else {
<span class="nc" id="L839">                        zzScanError(ZZ_NO_MATCH);</span>
                    }
            }
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>